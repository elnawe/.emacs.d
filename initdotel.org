#+TITLE: InitDotEl - Emacs configuration file
#+AUTHOR: Nahuel Jesús Sacchetti

* Bootstrap

** My better-defaults

Since I've been using Emacs I noticed some actual default variables are not the
best fit for me. I managed to put together a list of my better defaults and they
are here:

#+BEGIN_SRC emacs-lisp
(setq-default
 confirm-kill-emacs 'yes-or-no-p                         ; Confirm before exit
 cursor-in-non-selected-windows t                        ; Hide cursor in inactive windows
 delete-by-moving-to-trash t                             ; Move file to trash instead of removing it
 display-time-default-load-average nil                   ; Don't display load avereage
 display-time-format "%H:%M"                             ; Format the time string
 fill-column 80                                          ; Width before automatic line breaks
 frame-title-format "Emacs"                              ; Change frame title to "Emacs"
 help-window-select t                                    ; Focus help windows when opened
 indent-tabs-mode nil                                    ; Use spaces for indentation
 inhibit-startup-screen t                                ; Disable the startup window
 initial-scratch-message ""                              ; Empty *scratch* buffer
 left-margin-width 1 right-margin-width 0                ; Add left and right margins
 ring-bell-function 'ignore                              ; Ignore any kind of bell notifications
 scroll-conservatively most-positive-fixnum              ; Always scroll by one line
 scroll-margin 10                                        ; Add a margin when scrolling vertically
 select-enable-clipboard t                               ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                           ; End sentence when dot and space
 show-trailing-whitespace nil                            ; Display trailing whitespaces
 split-height-threshold nil                               ; Enable vertical splitting by 20 lines
 split-width-threshold nil                               ; Disable horizontal window splitting
 tab-width 4                                             ; Set indentation width
 truncate-lines t                                        ; Disable truncate lines
 uniquify-buffer-name-style 'forward                     ; Make buffer names unique
 visible-bell nil                                        ; Replace the alarm to an audible one
 window-combination-resize t                             ; Resize window proportionally
 x-stretch-cursor t)                                     ; Give cursor glyph width
(delete-selection-mode)                                  ; Replace region when inserting text
(display-time-mode)                                      ; Enable time-mode in mode-line
(fset 'yes-or-no-p 'y-or-n-p)                            ; Alias y/n prompts to yes/no
(fringe-mode 0)                                          ; No fringe!
(global-hl-line-mode)                                    ; Highlight current line
(global-subword-mode)                                    ; Iterate through camelCase words
(menu-bar-mode 0)                                        ; Disable the menu bar
(scroll-bar-mode 0)                                      ; Disable the scroll-bar
(tool-bar-mode 0)                                        ; Disable the tool-bar
(mouse-avoidance-mode 'none)                             ; Avoid mouse colission with point
#+END_SRC

** Personal information

#+BEGIN_SRC emacs-lisp
(setq
 user-full-name "Nahuel Jesús Sacchetti"
 user-mail-address "nahueljsacchetti@gmail.com")
#+END_SRC

** My variables

In order to maintain this configuration file I setted up some variables. These are carefully crafted and you should be
aware that editting these may cause trouble!

#+BEGIN_SRC emacs-lisp
(defvar elnawe/font-family "DejaVu Sans Mono-12" "Font used for theming")
(defvar elnawe/font-size 100 "Default font size")
(defvar elnawe/font-size-title 150 "Font size used in titles")
(defvar elnawe/start-time-seconds 10 "Time in seconds to start a mini application")
(defvar elnawe/update-time-seconds 1800 "Time in seconds to update/refresh mini applications")
#+END_SRC

** Helpers

This is a set of helper functions that are used in this configuration. Most of
them are just a way to /standarize/ the code.

#+BEGIN_SRC emacs-lisp
(defun elnawe::start-with-delay (FUNC)
  "Runs `FUNC' with a delay declared in
  `elnawe/start-time-seconds'. This function should be used to
  run smaller apps that are not crucial for Emacs to work."
  (run-at-time elnawe/start-time-seconds nil (funcall FUNC)))
#+END_SRC

** Garbage collection

Collect the garbage when you focus out, this feels a little bit faster

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** Load =.custom.el=

You can use the customization interface that Emacs provide but when you edit something, =init.el= is overriden with the
new configuration. To fix this, I move the Emacs customization changes to a new file and then I load it.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =secrets=

This loads a collection of secret and sensible information. I keep this file
separated to maintain privacy.

#+BEGIN_SRC emacs-lisp
(load "~/.elnawe.secrets/.emacs" t)
#+END_SRC

** OS specific configurations

Because I use Emacs everywhere, I need some extra configurations.

*** MacOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   elnawe/font-family "DejaVu Sans Mono-15"          ; Change font-family
   exec-path (append exec-path '("/usr/local/bin"))  ; Add Homebrew path
   ns-command-modifier 'meta                         ; Meta key is Command
   ns-option-modifier nil                            ; I use Alt/Option to expand my keyboard layout
   ns-right-option-modifier 'super                   ; Never use right Alt key so I can use it as Super key
   ns-use-srgb-colorspace nil))                      ; Using different colorspace for Mac
#+END_SRC

Intializing env inside Emacs

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config (exec-path-from-shell-initialize))
#+END_SRC

* Theme

** Remove the underlines on non-italic fonts

If font doesn't support italic text, by default Emacs tries to underline it and I don't like that.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'italic nil :underline nil)
#+END_SRC

** Zenburn theme and faces

Load zenburn theme and fix some faces with zenburn color variables

#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
  :init
  (load-theme 'zenburn t)
  :config
  (set-face-attribute 'font-lock-comment-face nil :italic t)
  (set-face-attribute 'font-lock-doc-face nil :italic t)

  (zenburn-with-color-variables
    (set-face-attribute 'button nil :foreground zenburn-yellow-2)
    (set-face-attribute 'default nil
                        :background zenburn-bg-05
                        :height elnawe/font-size
                        :font elnawe/font-family)
    (set-face-attribute 'help-argument-name nil :foreground zenburn-orange :italic nil)
    (set-face-attribute 'hl-line nil :background zenburn-bg+1)
    (set-face-attribute 'header-line nil
                        :background zenburn-bg-1
                        :box nil)
    (set-face-attribute 'region nil
                        :background zenburn-blue-5
                        :distant-foreground 'unspecified)
    (set-face-attribute 'vertical-border nil :foreground zenburn-bg))

  (zenburn-with-color-variables
    (mapc
     (lambda (face)
       (when (eq (face-attribute face :background) zenburn-bg)
         (set-face-attribute face nil :background 'unspecified)))
     (face-list))))
#+END_SRC

* Language support

I use Emacs for almost everything, but mostly to code. These are my configurations.

** C#

This is probably one of my favorite languages right now I don't really know why though everyone seems to hate it.

#+BEGIN_SRC emacs-lisp
(use-package csharp-mode
  :delight csharp-mode "C#"
  :init
  (add-hook 'csharp-mode-hook #'omnisharp-mode))

(use-package omnisharp
  :config
  (setq omnisharp-server-executable-path "/usr/local/bin/omnisharp"))
#+END_SRC

** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure nil
    :config
    (setq-default css-indent-offset 4))

  (use-package scss-mode
    :ensure nil
    :delight scss-mode "SCSS"
    :mode ("\\.sass\\'" "\\.scss\\'"))
#+END_SRC

** HTML

Using HTML mode defined in =sgml-mode.el=

#+BEGIN_SRC emacs-lisp
  (use-package sgml-mode
    :ensure nil
    :delight html-mode "HTML"
    :init
    (add-hook 'html-mode-hook #'sgml-electric-tag-pair-mode)
    (add-hook 'html-mode-hook #'sgml-name-8bit-mode)
    :config
    (setq sgml-basic-offset 4))
#+END_SRC

** JavaScript

I use =js2-mode= for my code since it looks and feels better.

- TODO: Add =rjsx-mode= to support React.

#+BEGIN_SRC emacs-lisp
(use-package js
  :init
  (add-hook 'js-mode #'js2-mode))

(use-package js2-mode
  :delight js2-mode "JavaScript"
  :mode ("\\.js\\'")
  :config
  (setq-default js-indent-level 4))

(use-package json-mode
  :delight json-mode "JSON")

(use-package ng2-mode
  :delight ng2-mode "Angular"
  :mode ("/futbol-club/.*\\.ts" "/futbol-club/.*\\.html")
  :config
  (delight 'ng2-ts-mode "Angular TypeScript")
  (delight 'ng2-html-mode "Angular HTML"))

(use-package rjsx-mode
  :delight rjsx-mode "React"
  :mode ("/swa-ui-app/.*\\.js$"))

(use-package tide)

(use-package typescript-mode
  :delight typescript-mode "TypeScript"
  :init
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode 1)
    (tide-hl-identifier-mode))
  (add-hook 'before-save-hook #'tide-format-before-save)
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
  :config
  (setq company-tooltip-align-annotations t))
#+END_SRC

** Lisp

Like I said: I use Emacs a lot... And I really mean a lot! Lisp isn't my favourite language, though I'm always using it.

#+BEGIN_SRC emacs-lisp
(use-package emacs-lisp-mode
  :ensure nil
  :delight emacs-lisp-mode "Emacs"
  :config
  (delight 'lisp-interaction-mode "Lisp Interaction"))

(use-package lisp-mode
  :ensure nil
  :delight lisp-mode "Lisp")
#+END_SRC

** Markdown

Mostly I use =org-mode=, but sometimes you need to write down your README files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :delight markdown-mode "Markdown"
    :mode ("INSTALL\\'" "LICENSE\\'" "README\\'" "\\.md\\'" "\\.markdown\\'")
    :config
    (setq-default
     markdown-asymmetric-header t
     markdown-split-window-direction 'right))
#+END_SRC

** Org

My whole configuration is written in =org-mode=. I also write all my TODO lists in Org. This is a powerful tool and I'm
not the best user. I'm learning though. Also, I'm working with [[Agenda administration][=org-agenda=]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :delight org-mode "Org"
  :init
  (add-hook 'org-mode-hook #'org-sticky-header-mode)
  (add-hook 'org-mode-hook #'org-bullets-mode)
  :config
  (setq
   org-descriptive-links nil
   org-ellipsis " ↓"
   org-support-shift-select 'always
   org-startup-folded nil
   org-startup-truncated nil
   org-todo-keywords '((sequence "TODO" "IN PROGRESS" "DONE")))

  (zenburn-with-color-variables
    (setq org-todo-keyword-faces '(("IN PROGRESS" . (:foreground zenburn-blue :weight bold))))))

(use-package org-src
  :ensure nil
  :after org
  :config
  (setq
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-fontify-natively t
   org-src-tab-acts-natively t
   org-src-window-setup 'current-window))
#+END_SRC

Display the Org header in the header-line

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :config
  (setq
   org-sticky-header-full-path 'full
   org-sticky-header-outline-path-separator " / "))
#+END_SRC

** Python

I'm not using =python-mode= all the time but sometimes I create little scripts to help me with the dirty work.

#+BEGIN_SRC emacs-lisp
(use-package python
  :ensure nil
  :delight python-mode "Python")

(use-package pip-requirements
  :delight pip-requirements-mode "PyPA Requirements")
#+END_SRC

* Major features

** Auto-completition

I'm not a very big fan of auto-complete my words but sometimes it's a bit helpful.

#+BEGIN_SRC emacs-lisp
(use-package company
  :config
  (global-company-mode)
  (setq
   company-idle-delay 0.5
   company-minimum-prefix-length 1
   company-tooltip-align-annotations t))
#+END_SRC

** Expanding code

Using built-in =hippie-exp= package to manage expansions. This is a DWIM-like (Do What I Mean) expansion, trying to be smart depending on its context.
Mostly you can use any kind of expansion with =<C-return>=

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  (:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil))
  :init
  (add-hook 'css-mode-hook #'emmet-mode)
  (add-hook 'html-mode-hook #'emmet-mode)
  (add-hook 'rjsx-mode-hook #'emmet-mode)
  :config
  (setq emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun elnawe/emmet-try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
     (interactive "P")
     (when emmet-mode (emmet-expand-line args)))
  :bind
  ("<C-return>" . hippie-expand)
  :config
  (setq-default
   hippie-expand-try-functions-list '(elnawe/emmet-try-expand-line)
   hippie-expand-verbose nil))
#+END_SRC

** Help

One great feature of Emacs is the self-documentation. This little configuration makes navigating through it a little bit easier.

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("q" . kill-buffer-and-window)
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Linting

I write a big amount of code everyday and sometimes I'm really inspired so I don't stop writing and coding. When I finish I've to double-check my code to see if I miss something and that's when my linting configuration kicks in.
This configuration need some binaries so don't forget to read my [[file+emacs:README.org][README.org]] to learn about this.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (add-hook 'emacs-lisp-mode-hook #'flycheck-mode)
  (add-hook 'js-mode-hook #'flycheck-mode)
  :config
  (setq
   flycheck-check-syntax-automatically '(save mode-enabled)
   flycheck-disabled-checkers '(emacs-lisp-checkdoc)
   flycheck-display-errors-delay .3)
  (zenburn-with-color-variables
    (set-face-attribute 'flycheck-error nil :underline zenburn-red)
    (set-face-attribute 'flycheck-info nil :underline zenburn-blue+1)
    (set-face-attribute 'flycheck-warning nil :underline zenburn-orange)
    (set-face-attribute 'flycheck-fringe-error nil :foreground zenburn-red)
    (set-face-attribute 'flycheck-fringe-info nil :foreground zenburn-blue+1)
    (set-face-attribute 'flycheck-fringe-warning nil :foreground zenburn-orange)))
#+END_SRC

** Mode-line

This is where I spend most of the time. I love customization and Emacs bring me something like this to play. I use =spaceline= to customize my mode-line, but I'm positive that in some future I will move back to =powerline=.

*** Delight

This package allows me to rename the major/minor modes "lightes", so they look more like a compact and  descriptive string instead of the awful name that they already have (I'm looking at you =js2-mode=). *NOTE*: Since this package is installed as main dependency, this piece of coude is merely for configuration.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure nil
  :config
  (defadvice powerline-major-mode (around delight-powerline-major-mode activate)
    (let ((inhibit-mode-name-delight nil)) ad-do-it)))
#+END_SRC

*** Forecast

Not going outside too much but always know what is happening out there.

#+BEGIN_SRC emacs-lisp
(use-package forecast
  :after spaceline
  :config
  (progn
    (run-at-time elnawe/start-time-seconds nil
                 (lambda ()
                   (forecast--load-data (lambda ()
                                          (forecast--make-buffer "*Weather Forecast*"))))))

  (run-at-time t elnawe/update-time-seconds (lambda ()
                                              (forecast-refresh))))
#+END_SRC

*** Icons

A fancy looking mode-line is fancy!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :after spaceline)
#+END_SRC

*** Spaceline

**** Setup

First, download Spaceline if doesn't exist and override =mode-line-format=.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :init
  (require 'spaceline-config)
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))
#+END_SRC

**** Define segments

After that I define all my custom segments.

#+BEGIN_SRC emacs-lisp
(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(spaceline-define-segment elnawe/buffer-id
  "Better buffer name, without mouse interaction"
  (concat
   "\xf1c9 "
  (buffer-name)))

(spaceline-define-segment elnawe/date-time
  "Better date time, removes (global)"
  (concat
   "\xf017 "
   (format-time-string "%a %d %b %H:%M" (current-time))))

(spaceline-define-segment elnawe/version-control
  "Minimal version control information."
  (when (fboundp 'magit-get-current-branch)
    (concat
     (with-face "\xe907 " '(:foreground "#DFAF8F"))
     (magit-get-current-branch)
     (powerline-raw
      (when (buffer-file-name)
        (pcase (vc-state (buffer-file-name))
          (`up-to-date "")
          (`edited " *")))))))

(spaceline-define-segment elnawe/twitter
  "Show Twitter notifications"
  (when (boundp 'twittering-unread-status-info)
    (with-face "\xf099" '(:foreground "#6CA0A3"))))

(spaceline-define-segment elnawe/forecast
  "Show the current temperature"
  (when (bound-and-true-p forecast--buffer)
    (propertize
     (concat
      (with-face "\xf185 " '(:foreground "#D0BF8F"))
      (forecast--temperature-string))
     'help-echo '(format
                  "Feels-like: %s\nDetails: %s\nHumidity: %s\nWind: %s\n\nUpdated %s"
                  (forecast--apparent-temperature)
                  (forecast--detailed-summary)
                  (forecast--humidity)
                  (forecast--wind-speed)
                  (format-time-string forecast-time-format forecast--update-time)))))
#+END_SRC

**** Configuration

Setup the actual configuration

#+BEGIN_SRC emacs-lisp
(setq
 powerline-default-separator 'arrow
 powerline-height 20
 spaceline-highlight-face-func 'spaceline-highlight-face-modified
 spaceline-separator-dir-left '(left . left)
 spaceline-separator-dir-right '(right . right))

(spaceline-install
  '((elnawe/buffer-id :face highlight-face)
    (elnawe/date-time)
    (elnawe/version-control)
    (elnawe/forecast)
    (elnawe/twitter))
  '((anzu :when active)
    (selection-info :when mark-active)
    ((flycheck-error flycheck-info flycheck-warning))
    (projectile-root)
    (line-column)
    ((hud buffer-position))
    (major-mode :face highlight-face)))
#+END_SRC

**** Theme

And there's some theme configuration going on

#+BEGIN_SRC emacs-lisp
(zenburn-with-color-variables
  (set-face-attribute 'mode-line nil
                      :background zenburn-bg-1
                      :box nil
                      :foreground zenburn-fg)
  (set-face-attribute 'powerline-active1 nil
                      :background zenburn-bg-1
                      :foreground zenburn-fg)
  (set-face-attribute 'powerline-active2 nil
                      :background zenburn-bg-05)
  (set-face-attribute 'mode-line-inactive nil
                      :background zenburn-bg-2
                      :box nil
                      :foreground zenburn-bg+3)
  (set-face-attribute 'powerline-inactive1 nil
                      :background zenburn-bg-2
                      :foreground zenburn-bg+3)
  (set-face-attribute 'powerline-inactive2 nil
                      :background zenburn-bg-1)
  (set-face-attribute 'spaceline-flycheck-error nil
                      :foreground zenburn-red)
  (set-face-attribute 'spaceline-flycheck-info nil
                      :foreground zenburn-blue+1)
  (set-face-attribute 'spaceline-flycheck-warning nil
                      :foreground zenburn-orange)
  (set-face-attribute 'spaceline-highlight-face nil
                      :background zenburn-yellow
                      :foreground zenburn-fg-1)
  (set-face-attribute 'spaceline-modified nil
                      :background zenburn-red
                      :foreground zenburn-red-4)
  (set-face-attribute 'spaceline-read-only nil
                      :background zenburn-blue+1
                      :foreground zenburn-blue-5)
  (set-face-attribute 'spaceline-unmodified nil
                      :background zenburn-green-1
                      :foreground zenburn-green+4))
#+END_SRC

** Navigation

Some helpers to navigate through and inside files

Smarter =C-a=. Props to: [[http://github.com/angrybacon][angrybacon]]

#+BEGIN_SRC emacs-lisp
(global-set-key [remap move-beginning-of-line] 'angrybacon/beginning-of-line-dwim)

(defun angrybacon/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
#+END_SRC

*** Go to definition

When working on big projects *go to definition* it's a must. =dumb-jump= helps me with that.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind
  (([f12] . dumb-jump-go)
   ("C-M-S-g" . dumb-jump-go-prefer-external-other-window))
  :config
  (dumb-jump-mode 1))
#+END_SRC

*** Mouse scrolling

I barely use my mouse but when I do...

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :ensure nil
  :config
  (setq
   mouse-wheel-progressive-speed nil
   mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control)))))
#+END_SRC

*** Search and replace

Better search and replace with =anzu=. This is a known =vim= package that [[https://github.com/syohex/emacs-anzu][syohex]] ported to Emacs. Also, here I've some =isearch= configuration to work with better regexp searching mechanics.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind ([remap query-replace] . anzu-query-replace-regexp)
  :config
  (global-anzu-mode)
  (setq-default
   anzu-cons-mode-line-p nil)
  (zenburn-with-color-variables
    (set-face-attribute 'anzu-replace-highlight nil
                        :background zenburn-red-4
                        :foreground zenburn-red+1)
    (set-face-attribute 'anzu-replace-to nil
                        :background zenburn-green-1
                        :foreground zenburn-green+4)))

(use-package isearch
  :ensure nil
  :bind
  (("C-S-r" . isearch-backward-regexp)
   ("C-S-s" . isearch-forward-regexp)
   :map isearch-mode-map
   ("<M-down>" . isearch-ring-advance)
   ("<M-up>" . isearch-ring-retreat)
   :map minibuffer-local-isearch-map
   ("<M-down>" . next-history-element)
   ("<M-up>" . previous-history-element))
  :init
  (setq-default
   isearch-allow-scroll t
   lazy-highlight-cleanup nil
   lazy-highlight-initial-delay 0)
  (zenburn-with-color-variables
    (set-face-attribute 'isearch nil
                        :background zenburn-blue
                        :foreground zenburn-blue-5)
    (set-face-attribute 'isearch-lazy-highlight-face nil
                        :background zenburn-blue-5
                        :foreground zenburn-blue)))
#+END_SRC

** Parentheses

When programming, I use different kind of wrapper. Lisp knows it well.

Some useful and native configuration first

#+BEGIN_SRC emacs-lisp
(use-package show-paren-mode
  :ensure nil
  :init
  (show-paren-mode t))
#+END_SRC

This one highlight my delimiters in a rainbow. Super easy to read, right?

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'rainbow-delimiters-mismatched-face nil
                        :foreground zenburn-red-4)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground zenburn-red-4)))
#+END_SRC

Also I use =smartparens= to be sure I don't forget to close 'em! It takes some time to be used to it though.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("M-<backspace>" . sp-unwrap-sexp)
   ("M-<left>" . sp-forward-barf-sexp)
   ("M-<right>" . sp-forward-slurp-sexp)
   ("M-S-<left>" . sp-backward-slurp-sexp)
   ("M-S-<right>" . sp-backward-barf-sexp)))

(use-package smartparens-config
  :ensure nil
  :after smartparens
  :config
  (smartparens-global-mode)
  (sp-pair "{{" "}}")
  (sp-pair "[[" "]]"))
#+END_SRC

** Project management

I love =projectile= and I think its the best project management tool you'll ever need in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" user-emacs-directory)
   projectile-keymap-prefix (kbd "<f5>")
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory)
   projectile-switch-project-action 'projectile-find-file)
  :config
  (projectile-global-mode)
  (setq
   projectile-completition-system 'ido
   projectile-enable-caching t
   projectile-mode-line '(:eval (projectile-project-name)))
  :bind
  ("C-p" . projectile-find-file))
#+END_SRC

** Tree View

I don't use this often but it's a good thing to have in hand if I need to find a
file by its folder.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind
  (([f6] . neotree-toggle)
   :map neotree-mode-map
   ("<return>" . neotree-enter)
   ("c" . neotree-create-node)
   ("d" . neotree-delete-node)
   ("r" . neotree-rename-node)
   ("s" . neotree-dir))
  :config
  (setq
   neo-autorefresh t
   neo-force-change-root t
   neo-smart-open t
   neo-theme (if (display-graphic-p) 'icons 'arrow)
   neo-vc-integration '(face char)
   neo-window-width 50
   neo-window-position 'right)

  (zenburn-with-color-variables
    (set-face-attribute 'neo-vc-edited-face nil
                        :foreground zenburn-yellow-1)
    (set-face-attribute 'neo-vc-added-face nil
                        :foreground zenburn-green-1)))
#+END_SRC

** Version Control

Magit provides everything I need when working with Version Control, all within Emacs. Also, it merges very well with my
=mode-line= configuration.

#+BEGIN_SRC emacs-lisp
(use-package git-commit
  :preface
  (defun elnawe/git-commit-auto-fill ()
    (setq-local comment-auto-fill-only-comments nil))
  :init
  (add-hook 'git-commit-mode-hook #'elnawe/git-commit-auto-fill)
  :config
  (setq-default git-commit-summary-max-length 50))

(use-package magit
  :preface
  (defun elnawe/magit-display-buffer-same (buffer)
    "Display most magit popups in the current buffer."
    (display-buffer
     buffer
     (cond ((and (derived-mode-p 'magit-mode)
                 (eq (with-current-buffer buffer major-mode) 'magit-status-mode))
            nil)
           ((memq (with-current-buffer buffer major-mode)
                  '(magit-process-mode
                    magit-revision-mode
                    magit-diff-mode
                    magit-stash-mode))
            nil)
           (t '(display-buffer-same-window)))))
  :config
  (setq-default
   magit-display-buffer-function #'elnawe/magit-display-buffer-same
   magit-diff-highlight-hunk-body nil
   magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside
     magit-diff-highlight-hunk-region-using-face)
   magit-popup-display-buffer-action '((display-buffer-same-window))
   magit-refs-show-commit-count 'all
   magit-section-show-child-count t)
  (delight
   '((magit-diff-mode "Git Diff")
     (magit-log-mode "Git Log")
     (magit-popup-mode "Magit Popup")
     (magit-status-mode "Git Status")))
  (set-face-attribute 'magit-diff-file-heading-highlight nil :background nil)
  (set-face-attribute 'magit-diff-hunk-region nil :inherit 'region)
  (set-face-attribute 'magit-popup-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-highlight nil :background nil)
  (zenburn-with-color-variables
    (set-face-attribute 'magit-diff-added nil
                        :background nil
                        :foreground zenburn-green+3)
    (set-face-attribute 'magit-diff-removed nil
                        :background nil
                        :foreground zenburn-red)))
#+END_SRC

** Whitespaces

Highlight trailing whitespaces, tabs and empty lines. Also remove them when saving the file.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :demand t
  :ensure nil
  :init
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (add-hook 'prog-mode-hook #'whitespace-turn-on)
  (add-hook 'text-mode-hook #'whitespace-turn-on)
  :config
  (setq-default whitespace-style '(face tab trailing)))
#+END_SRC

** Window management

When using Emacs you want to customize how windows, buffers and modes are saved.

List all buffers and group them by type.

#+BEGIN_SRC emacs-lisp
(use-package ibuffer
  :ensure nil
  :delight ibuffer-mode "Buffers"
  :bind
  (("C-x c b" . ibuffer))
  :init
  (add-hook 'ibuffer-mode-hook (lambda ()
                                 (setq ibuffer-filter-groups
                                       '(("Apps" (or (name . "^\\*Weather Forecast\\*$")
                                                     (mode . twittering-mode)))
                                         ("Directories" (mode . dired-mode))
                                         ("Lisp" (or (mode . lisp-mode)
                                                     (mode . emacs-lisp-mode)))
                                         ("Org" (mode . org-mode))
                                         ("system" (or (name . "^\\*scratch\\*$")
                                                       (name . "^\\*Messages\\*$")
                                                       (name . "^\\*Warnings\\*$")))))))
  :config
  (setq-default
   ibuffer-default-sorting-mode 'major-mode
   ibuffer-formats '((mark modified read-only " " (name 18 18 :left :elide) " " (mode 16 16 :left :elide) " " filename-and-process))
   ibuffer-use-other-window t))

(use-package ibuffer-projectile
  :init
  (defun elnawe/ibuffer-sorting ()
    "Sort buffers with projectile, alphabetic and major mode"
    (ibuffer-do-sort-by-alphabetic)
    (ibuffer-do-sort-by-major-mode))

  (add-hook 'ibuffer-hook #'elnawe/ibuffer-sorting))
#+END_SRC

This function allows repeated use of =←= and =→= when using =previous-buffer= and =next-buffer=. Again, props to
[[http://github.com/angrybacon/][angrybacon]].

#+BEGIN_SRC emacs-lisp
(defun angrybacon/switch-to-buffer-continue ()
  "Activate a sparse keymap:
  <left>   `previous-buffer'
  <right>  `next-buffer'"
  (set-transient-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "<left>") #'previous-buffer)
     (define-key map (kbd "<right>") #'next-buffer)
     map)))
(advice-add 'previous-buffer :after #'angrybacon/switch-to-buffer-continue)
(advice-add 'next-buffer :after #'angrybacon/switch-to-buffer-continue)
#+END_SRC

Save and restore Emacs status

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :ensure nil
  :demand t
  :config
  (desktop-save-mode)
  (add-to-list 'desktop-globals-to-save 'golden-ratio-adjust-factor))
#+END_SRC

Move around windows with ease.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("<f2> <left>". windmove-left)
   ("<f2> <right>". windmove-right)
   ("<f2> <up>". windmove-up)
   ("<f2> <down>". windmove-down)
   ("<f2> <f2>" . other-window)))
#+END_SRC

Window splitting. After create a new window, switch to the new one.

#+BEGIN_SRC emacs-lisp
(defun elnawe/create-bottom-and-switch ()
  "Creates a new window to the bottom and then switch to it"
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun elnawe/create-right-and-switch ()
  "Creates a new window to the right and then switch to it"
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'elnawe/create-bottom-and-switch)
(global-set-key (kbd "C-x 3") 'elnawe/create-right-and-switch)
#+END_SRC

Split horizontally for new temporary buffers. Props to: [[https://github.com/hrs][hrs]].

#+BEGIN_SRC emacs-lisp
(defun hrs/split-horizontally-for-temp-buffers ()
  (when (one-window-p t)
    (split-window-horizontally)))

(add-hook 'temp-buffer-window-setup-hook
          'hrs/split-horizontally-for-temp-buffers)
#+END_SRC

Undo and redo with the window configuration using =C-c left= to undo and =C-c right= to redo.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :defer 1
  :config (winner-mode))
#+END_SRC

* Emacs everyday

Since I use Emacs all the time, everyday, almost for everything I need some neat configurations. They are all here.

** Agenda administration

*** Setup directories and configuration

Setup directory for org files, save my =TODOs= to a index file and maintain an inbox in Dropbox. Also, archive all
=DONE= tasks to =~/orgs/archive.org=.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/orgs")

(defun org-file-path (filename)
  "Return the absolute address of an org file, given its relative name."
  (concat (file-name-as-directory org-directory) filename))

(setq
 org-index-file (org-file-path "index.org")
 org-archive-location (concat (org-file-path "archive.org") ":: From %s"))
#+END_SRC

All my =TODOs= are in the =index.org= so I'll load my agenda from there.

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files (list org-index-file))
#+END_SRC

Record the time when =TODO= was archived.

#+BEGIN_SRC emacs-lisp
(setq org-log-done 'time)
#+END_SRC

*** Capturing new tasks

Defining templates for capturing new tasks. Also, quickly capture =TODO=.

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(("t" "Todo"
         entry
         (file+headline org-index-file "Inbox")
         "* TODO %?\n")
        ("i" "Ideas"
         entry
         (file (org-file-path "ideas.org"))
         "* TODO %?\n")))

(defun org-capture-todo ()
  (interactive)
  (org-capture :keys "t"))

(global-set-key (kbd "M-n") 'org-capture-todo)
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp
(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)

(defun elnawe/mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(defun open-index-file ()
  "Open the master org TODO list."
  (interactive)
  (find-file org-index-file)
  (flycheck-mode -1)
  (end-of-buffer))

(global-set-key (kbd "C-c i") 'open-index-file)
(define-key org-mode-map (kbd "C-c C-x C-s") 'elnawe/mark-done-and-archive)
#+END_SRC

** Auto-indent as you write

Helps me to maintain my code aligned with aggresive indentation

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :config
  (aggressive-indent-global-mode))
#+END_SRC

** Backup copies

Manage the backup copies. Always keeping them but save them inside Emacs directory.

#+BEGIN_SRC emacs-lisp
(setq-default
 backup-by-copying t
 backup-directory-alist '(("." . "~/.emacs.d/saves"))
 delete-old-versions 'never
 make-backup-files t
 version-control 'numbered)
#+END_SRC

** Dim other buffers

Automatically dim my other buffers

#+BEGIN_SRC emacs-lisp
(use-package auto-dim-other-buffers
  :init
  (auto-dim-other-buffers-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'auto-dim-other-buffers-face nil :background zenburn-bg-1)))
#+END_SRC

** Disable documentation at point

I don't want to see documentation in the echo area because it conflicts with =flycheck=

#+BEGIN_SRC emacs-lisp
(use-package eldoc
  :ensure nil
  :config
  (global-eldoc-mode -1))
#+END_SRC

** Fill paragraph automatically

When I'm in =text-mode= I want my paragraph to be just the lenght of my ruler. Also, I don't want to use =M-q= to adjust
it by myself, because Emacs allow me to do it automatically!

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :config
  (add-hook 'text-mode-hook #'turn-on-auto-fill))
#+END_SRC

** Interactively doing things =ido=

I use =ido-mode= because it feels super fast. I like what =helm= does but makes my editor look like any other modern
editor. I use =ido-vertical-mode= to order my list with a neat look and also =flx-ido= to better matching.

#+BEGIN_SRC emacs-lisp
(use-package ido
  :init
  (ido-mode 1)
  :bind
  (("C-x C-b" . ido-switch-buffer))
  :config
  (setq-default
   ido-create-new-buffer 'always
   ido-enable-flex-matching t
   ido-everywhere t
   ido-file-extensions-order '(".js" ".org" ".el" ".json")
   ido-ignore-buffers '("\\ " "*scratch*" "*Ibuffer*" "*Completions*" "*Backtrace*")
   ido-use-filename-at-point 'guess))

(use-package ido-vertical-mode
  :init
  (ido-vertical-mode 1)
  :config
  (setq-default
   ido-use-faces t
   ido-vertical-define-keys 'C-n-C-p-up-and-down
   ido-vertical-show-count t)

  (zenburn-with-color-variables
    (set-face-attribute 'ido-vertical-first-match-face nil
                        :background zenburn-bg+1
                        :bold t
                        :foreground zenburn-yellow-1)
    (set-face-attribute 'ido-vertical-only-match-face nil
                        :background nil
                        :foreground nil)
    (set-face-attribute 'ido-vertical-match-face nil
                        :foreground nil)))

(use-package flx-ido
  :init
  (flx-ido-mode 1))
#+END_SRC

Also =smex= helps me go through =M-x= easily and with all the benefits of =ido-mode=

#+BEGIN_SRC emacs-lisp
(use-package smex
  :init
  (smex-initialize)
  :bind
  ("M-x" . smex))
#+END_SRC

** Kill unused buffers

Clean my buffer list on delay with =midnight= beucase I leave Emacs always open. Keep this configuration always alive.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :ensure nil
  :init
  (add-hook 'midnight-mode #'clean-buffer-list)
  (midnight-mode 1)
  :config
  (setq clean-buffers-list-delay-general 1)
  (add-to-list 'clean-buffer-list-kill-never-buffer-names "initdotel.org"))
#+END_SRC

* Networking

Using Emacs for everything includes using it for social media.

** Twitter

I often use Twitter and when I do it is inside Emacs.

#+BEGIN_SRC emacs-lisp
(use-package twittering-mode
  :delight twittering-mode "Twitter"
  :config
  (setq
   twittering-display-remaining t
   twittering-icon-mode t
   twittering-icon-storage-file "~/.emacs.d/cache"
   twittering-retweet-format '(nil _ "RT @%s: %t")
   twittering-timer-interval elnawe/update-time-seconds
   twittering-use-icon-storage t
   twittering-use-master-password t))
#+END_SRC
