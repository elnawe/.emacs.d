#+TITLE: Configuration.org - A literate programming for my Emacs configuration
#+AUTHOR: Nahuel Jesús Sacchetti
#+OPTIONS: toc:3

* Introduction

Welcome to my configuration file for GNU Emacs.

#+BEGIN_QUOTE
Emacs was originally an extensible text editor written by Richard
Stallman, but it became a way of life and a religion. Emacs is love,
Emacs is life.
#+END_QUOTE

This is my third version of the configuration file. I've been learning a
lot lately and I felt the responsability of updating this file to match
all my new "standards" and also to keep those really clear.

** =TODOs=

This section is inteded to have all the things I want =todo= but I do
not have time to right now.

** Personal information

#+BEGIN_SRC emacs-lisp
(setq
 user-full-name "Nahuel Jesús Sacchetti"
 user-mail-address "nahueljsacchetti@gmail.com")
#+END_SRC

* Bootstrapping my Emacs

It's nice to have your Emacs /standarided/ and feel that you're using
the same configuration everywhere.

** Custom variables

#+BEGIN_SRC emacs-lisp
(defvar elnawe/font-family "DejaVu Sans Mono-12" "Font used for theming")
(defvar elnawe/font-size 100 "Default font size")
(defvar elnawe/font-size-title 150 "Font size used in titles")
(defvar elnawe/start-time-seconds 20 "Time in seconds to start a mini application")
(defvar elnawe/update-time-seconds 1800 "Time in seconds to update/refresh mini applications")
(defvar elnawe/icons-enabled t "Show/hide special icons. Most of them used in mode-line")
#+END_SRC

** Make Emacs faster

Collect garbage when focus out your Emacs.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** My better-defaults

Since I've been using Emacs I noticed some actual default variables are
not the best fit for me. I managed to put together a list of my better
defaults and they are here:

#+BEGIN_SRC emacs-lisp
(setq-default
 confirm-kill-emacs 'yes-or-no-p                           ; Confirm before exit
 cursor-in-non-selected-windows t                          ; Hide cursor in inactive windows
 delete-by-moving-to-trash t                               ; Move file to trash instead of removing it
 display-time-default-load-average nil                     ; Don't display load avereage
 display-time-format "%H:%M"                               ; Format the time string
 fill-column 72                                            ; Width before automatic line breaks
 frame-title-format "Emacs"                                ; Change frame title to "Emacs"
 help-window-select t                                      ; Focus help windows when opened
 indent-tabs-mode nil                                      ; Use spaces for indentation
 inhibit-startup-screen t                                  ; Disable the startup window
 initial-scratch-message ""                                ; Empty *scratch* buffer
 left-margin-width 1 right-margin-width 0                  ; Add left and right margins
 view-read-only t                                          ; View the readonly files
 ring-bell-function 'ignore                                ; Ignore any kind of bell notifications
 scroll-conservatively most-positive-fixnum                ; Always scroll by one line
 scroll-margin 10                                          ; Add a margin when scrolling vertically
 select-enable-clipboard t                                 ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                             ; End sentence when dot and space
 show-trailing-whitespace nil                              ; Display trailing whitespaces
 split-height-threshold nil                                ; Disable vertical splitting
 split-width-threshold 1000                                ; Enable horizontal splitting
 tab-width 4                                               ; Set indentation width
 truncate-lines t                                          ; Disable truncate lines
 uniquify-buffer-name-style 'forward                       ; Make buffer names unique
 visible-bell nil                                          ; Replace the alarm to an audible one
 window-combination-resize t                               ; Resize window proportionally
 x-stretch-cursor t)                                       ; Give cursor glyph width
(delete-selection-mode)                                    ; Replace region when inserting text
(display-time-mode)                                        ; Enable time-mode in mode-line
(fset 'yes-or-no-p 'y-or-n-p)                              ; Alias y/n prompts to yes/no
(fringe-mode 0)                                            ; No fringe!
(global-hl-line-mode)                                      ; Highlight current line
(global-subword-mode)                                      ; Iterate through camelCase words
(menu-bar-mode 0)                                          ; Disable the menu bar
(scroll-bar-mode 0)                                        ; Disable the scroll-bar
(tool-bar-mode 0)                                          ; Disable the tool-bar
(mouse-avoidance-mode 'none)                               ; Avoid mouse colission with point
(define-key global-map "\C-ci" #'elnawe::open-config-file) ; Binds `C-ci' to open the configuration
#+END_SRC

** Helpers

This is a set of helper functions that are used in this configuration.

#+BEGIN_SRC emacs-lisp
(defun elnawe::start-with-delay (FUNC)
  "Runs `FUNC' with a delay declared in
  `elnawe/start-time-seconds'. This function should be used to
  run smaller apps that are not crucial for Emacs to work"
  (run-at-time elnawe/start-time-seconds nil (funcall FUNC)))

(defun elnawe::load-package-dir (PACKAGE)
  "Returns package `PACKAGE' from /packages directory"
  (concat user-emacs-directory "packages/" PACKAGE))

(defun elnawe::open-config-file ()
  "Opens the config file `initdotel.org' on a new buffer"
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

(defun elnawe::get-configurations-folder ()
  "Returns the folder where configuration files are stored"
  (concat (getenv "HOME") "/.emacs.config"))
#+END_SRC

** OS specific configurations

Because I use Emacs everywhere, I need some extra configurations.

*** MacOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   elnawe/font-family "DejaVu Sans Mono-15"          ; Change font-family
   exec-path (append exec-path '("/usr/local/bin"))  ; Add Homebrew path
   ns-command-modifier 'meta                         ; Meta key is Command
   ns-option-modifier nil                            ; I use Alt/Option to expand my keyboard layout
   ns-right-option-modifier 'super                   ; Never use right Alt key so I can use it as Super key
   ns-use-srgb-colorspace nil))                      ; Using different colorspace for Mac
#+END_SRC

Intializing env inside Emacs

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config (exec-path-from-shell-initialize))
#+END_SRC

*** TOS

I'm a pretty big fan of Terminal Operating System and my desktop (and
one of my laptops) has a clean ArchLinux installed with no visual
desktop o GUI. These configurations are needed to ensure that my Emacs
works well on those boxes!

#+BEGIN_SRC emacs-lisp
(when (not window-system)
  (setq-default
   elnawe/icons-enabled nil)
  (global-hl-line-mode -1))
#+END_SRC

** Load =.custom.el=

You can use the customization interface that Emacs provide but when you
edit something, =init.el= is overriden with the new configuration. To
fix this, I move the Emacs customization changes to a new file and then
I load it.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =secrets=

This loads a collection of secret and sensible information. I keep this
file separated to maintain privacy.

#+BEGIN_SRC emacs-lisp
(load "~/.elnawe.secrets/.emacs" t)
#+END_SRC

* Theming

** Zenburn

It's the best thing that happened to me since I started programming. I'm
just in love with *Zenburn*. By the way, everything I use looks like
Zenburn. [[https://github.com/bbatsov/zenburn-emacs][This]] is the theme
I use.

#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
  :init
  (load-theme 'zenburn t)
  :config
  (set-face-attribute 'font-lock-comment-face nil :italic nil)

  (zenburn-with-color-variables
    (set-face-attribute 'button nil
                        :foreground zenburn-yellow-2)
    (set-face-attribute 'default nil
                        :background zenburn-bg-05
                        :height elnawe/font-size
                        :font elnawe/font-family)
    (set-face-attribute 'font-lock-warning-face nil
                        :foreground zenburn-green+2
                        :underline '(:style wave)
                        :weight 'bold)
    (set-face-attribute 'help-argument-name nil
                        :foreground zenburn-orange
                        :italic nil)
    (set-face-attribute 'hl-line nil :background zenburn-bg+1)
    (set-face-attribute 'header-line nil
                        :background zenburn-bg-1
                        :box nil)
    (set-face-attribute 'region nil
                        :background zenburn-blue
                        :foreground zenburn-bg)
    (set-face-attribute 'vertical-border nil
                        :foreground zenburn-yellow-2)
    (mapc
     (lambda (face)
       (when (eq (face-attribute face :background) zenburn-bg)
         (set-face-attribute face nil
                             :background 'unspecified)))
     (face-list))))
#+END_SRC

* Emacs everyday

** Agenda

When you use Emacs for a while you understand that you can not just edit
code, create presentations or write quite beautiful tables and lists.
You can also have a very nice =TODO= list synched all the time with your
server that acts as your agenda and note-taking. This is actually nice.

*** Directories

#+BEGIN_SRC emacs-lisp
(setq-default
 org-directory "~/Dropbox/orgs")

(defun elnawe::org/file-path (FILENAME)
  "Returns the absolute path of a given `FILENAME` with default `org-directory`"
  (concat (file-name-as-directory org-directory) FILENAME))

(setq
 org-archive-location (concat (elnawe::org/file-path "archive.org") ":: From %s")
 org-index-file (elnawe::org/file-path "index.org"))
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp
(defun elnawe::org/mark-done-and-archive ()
  "Mark the state of an org-mode item as `DONE' and archive it"
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)
(define-key org-mode-map (kbd "C-c C-x C-s") 'elnawe::org/mark-done-and-archive)
#+END_SRC

*** New captures

#+BEGIN_SRC emacs-lisp
(setq
 org-agenda-files (list org-index-file)
 org-capture-templates '(("i" "Ideas"
                          entry
                          (file (elnawe::org/file-path "ideas.org"))
                          "* %?\n")
                         ("t" "TODO"
                          entry
                          (file+headline org-index-file "Inbox")
                          "* TODO %?\n"))
 org-log-done 'time)
#+END_SRC

** Backup copies

Manage the backup copies. Always keeping them but save them inside Emacs
directory.

#+BEGIN_SRC emacs-lisp
(setq-default
 backup-by-copying t
 backup-directory-alist '(("." . "~/.emacs.config/saves"))
 delete-old-versions 'never
 make-backup-files t
 version-control 'numbered)
#+END_SRC

** Dim other buffers

Automatically dim my other opened buffers. This help me focus on the one
that is being reading/modifying.

#+BEGIN_SRC emacs-lisp
(use-package auto-dim-other-buffers
  :init
  (auto-dim-other-buffers-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'auto-dim-other-buffers-face nil
                        :background zenburn-bg-1)))
#+END_SRC

** Fill paragraph automatically

When I'm in =text-mode= I want my paragraph to be just the lenght of my
ruler. Also, I don't want to use =M-q= to adjust it by myself, because
Emacs allow me to do it automatically!

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :init
  (add-hook 'text-mode-hook #'turn-on-auto-fill))
#+END_SRC

** =ivy-mode= for minibuffer completition

First I used =helm= but it felt slow. Then I moved to the built-in
=ido-mode= and, though it worked great, I wanted to try =ivy= and after
searching the Internet I found it very useful!

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :bind
  ((:map ivy-switch-buffer-map
         ("C-k" . elnawe::ivy/kill-buffer)))
  :init
  (ivy-mode 1)
  (defun elnawe::ivy/kill-buffer ()
    "Kill the selected buffer from the `ivy-switch-buffer' menu."
    (interactive)
    (ivy-set-action 'kill-buffer)
    (ivy-done))
  :config
  (setq
   enable-recursive-minibuffers t
   ivy-count-format "[%d/%d] "
   ivy-display-style 'fancy
   ivy-extra-directories nil
   ivy-use-virtual-buffers t))

(use-package counsel)

(use-package swiper)
#+END_SRC

** Navigation

Navigation its an important thing in Emacs, specially when you just use
the keyboard.

*** Beginning of line

This is a better =move-beginning-of-line= function that also goes to
beginning after indentation.

#+BEGIN_SRC emacs-lisp
(defun elnawe::/dwinbeginning-of-line ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))

(global-set-key [remap move-beginning-of-line] #'elnawe::/dwinbeginning-of-line)
#+END_SRC

*** Disable mouse

#+BEGIN_SRC emacs-lisp
(use-package disable-mouse
  :init
  (global-disable-mouse-mode))
#+END_SRC

*** Vi-like navigation

I tend to use the terminal a lot and most of the programs you use there
uses a vi-like navigation. You just get used to it.

#+BEGIN_SRC emacs-lisp
(add-hook 'read-only-mode-hook
          (lambda ()
            (define-key view-mode-map "J" #'scroll-up-line)
            (define-key view-mode-map "K" #'scroll-down-line)
            (define-key view-mode-map "j" #'next-line)
            (define-key view-mode-map "k" #'previous-line)
            (define-key view-mode-map "l" #'right-char)
            (define-key view-mode-map "h" #'left-char)
            (define-key view-mode-map "i" #'read-only-mode)))

(define-key global-map [f4] #'read-only-mode)
(define-key global-map "\M-3" #'read-only-mode)
#+END_SRC

** Restart Emacs

When I am updating or changing some configuration on my Emacs I like to
restart it to clean up everything I removed. There's an excellent
package to do that and it's called =restart-emacs=. Instead of =C-x C-c=
(quit-emacs) I use =C-x C-M-c= to restart it.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :bind
  ("C-x C-M-c" . restart-emacs))
#+END_SRC

** Window management

Window management is something you have to do in Emacs, and you'll have
to do it a lot. This is a great set of configurations to make it look
and feel easy to do.

*** Destkop

For Emacs =desktop= is the working session you left off when closing it.
I like to keep it always there so I can continue from that point.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :ensure nil
  :demand t
  :config
  (desktop-save-mode))
#+END_SRC

*** Moving through windows

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-c m h". windmove-left)
   ("C-c m l". windmove-right)
   ("C-c m k". windmove-up)
   ("C-c m j". windmove-down)
   ("C-c m o" . other-window)))
#+END_SRC

*** Splitting windows

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/create-bottom-and-switch ()
  "Creates a new window to the bottom and then switch to it"
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun elnawe::window/create-right-and-switch ()
  "Creates a new window to the right and then switch to it"
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'elnawe::window/create-bottom-and-switch)
(global-set-key (kbd "C-x 3") 'elnawe::window/create-right-and-switch)
(global-set-key (kbd "C-x `") 'ivy-switch-buffer-other-window)
#+END_SRC

*** Temporal buffers

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/split-horizontally-for-temp-buffers ()
  (when (one-window-p t)
    (split-window-horizontally)))

(add-hook 'temp-buffer-window-setup-hook
          'elnawe::window/split-horizontally-for-temp-buffers)
#+END_SRC

*** Undo/redo configurations

Sometimes you close windows or change their layout without meaning to.
Thanks to Emacs =winner= mode helps me to go back if that happens.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :defer 1
  :bind
  (("C-c b M-h" . winner-undo)
   ("C-c b M-l" . winner-redo))
  :init
  (winner-mode))
#+END_SRC

* Programming

I use Emacs for everything, even code. I like to keep it good looking
but really functional.

** Auto-completition

I'm not a very big fan of auto-complete my words but sometimes it's a
bit helpful.

#+BEGIN_SRC emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook #'global-company-mode)
  :config
  (setq
   company-idle-delay 0.3
   company-minimum-prefix-length 3
   company-tooltip-align-annotations t))
#+END_SRC

** Auto-indent as you write

Helps me to maintain my code aligned with aggresive indentation.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :init
  (aggressive-indent-global-mode))
#+END_SRC

** Expanding code

Using built-in =hippie-exp= package to manage expansions. This is a
DWIM-like (Do What I Mean) expansion, trying to be smart depending on
its context. Mostly you can use any kind of expansion with =<C-return>=

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  ((:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil)))
  :init
  (add-hook 'css-mode-hook #'emmet-mode)
  (add-hook 'html-mode-hook #'emmet-mode)
  (add-hook 'rjsx-mode-hook #'emmet-mode)
  :config
  (setq emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun elnawe::emmet/try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
     (interactive "P")
     (when emmet-mode (emmet-expand-line args)))
  :bind
  (("<C-return>" . hippie-expand))
  :config
  (setq-default
   hippie-expand-try-functions-list '(elnawe::emmet/try-expand-line)
   hippie-expand-verbose nil))
#+END_SRC

** Go to definition

When working on big projects *go to definition* it's a must. =dumb-jump=
helps me with that.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind
  (("C-c l g" . dumb-jump-go)
   ("C-c l n" . dumb-jump-go-prefer-external-other-window))
  :init
  (dumb-jump-mode 1))
#+END_SRC

** Languages

*** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure nil
    :config
    (setq-default css-indent-offset 4))

  (use-package scss-mode
    :ensure nil
    :delight scss-mode "SCSS"
    :mode ("\\.sass\\'" "\\.scss\\'"))
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp
(use-package js
  :init
  (add-hook 'js-mode #'js2-mode))

(use-package js2-mode
  :delight js2-mode "JavaScript"
  :mode ("\\.js\\'")
  :config
  (setq js-indent-level 4))

(use-package json-mode
  :delight json-mode "JSON")

(use-package ng2-mode
  :delight ng2-mode "Angular"
  :mode ("/futbol-club/.*\\.ts" "/futbol-club/.*\\.html")
  :config
  (delight 'ng2-ts-mode "Angular TypeScript")
  (delight 'ng2-html-mode "Angular HTML"))

(use-package rjsx-mode
  :delight rjsx-mode "React"
  :mode ("/swa-ui-app/.*\\.js$"))

(use-package tide)

(use-package typescript-mode
  :delight typescript-mode "TypeScript"
  :init
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode 1)
    (tide-hl-identifier-mode))
  (add-hook 'before-save-hook #'tide-format-before-save)
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
  :config
  (setq company-tooltip-align-annotations t))
#+END_SRC

*** Lisp

Like I said: I use Emacs a lot... And I really mean a lot! Lisp isn't my
favourite language, though I'm always using it.

#+BEGIN_SRC emacs-lisp
(use-package emacs-lisp-mode
  :ensure nil
  :delight emacs-lisp-mode "Emacs"
  :config
  (delight 'lisp-interaction-mode "Lisp Interaction"))

(use-package lisp-mode
  :ensure nil
  :delight lisp-mode "Lisp")
#+END_SRC

*** Markdown

Mostly I use =org-mode=, but sometimes you need to write down your
README files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :delight markdown-mode "Markdown"
    :mode ("INSTALL\\'" "LICENSE\\'" "README\\'" "\\.md\\'" "\\.markdown\\'")
    :config
    (setq
     markdown-asymmetric-header t
     markdown-split-window-direction 'right))
#+END_SRC

*** Org

My whole configuration is written in =org-mode=. I also write all my
TODO lists in Org. This is a powerful tool and I'm not the best user.
I'm learning though. Also, I'm working with [[Agenda][=org-agenda=]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :delight org-mode "Org Mode"
  :init
  (add-hook 'org-mode-hook #'org-sticky-header-mode)
  (add-hook 'org-mode-hook #'org-bullets-mode)
  :config
  (setq
   org-descriptive-links nil
   org-ellipsis "\u21b4"
   org-startup-folded nil
   org-startup-truncated nil))

(use-package org-src
  :ensure nil
  :after org
  :config
  (setq
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-fontify-natively t
   org-src-tab-acts-natively t
   org-src-window-setup 'current-window))

(use-package org-sticky-header
  :config
  (setq
   org-sticky-header-full-path 'full
   org-sticky-header-outline-path-separator " > "))
#+END_SRC

** Multiple cursors

I actually like some of the features that modern IDE provides, like
multiple cursor editing. It's great that Emacs can do that as well!

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C-c l e" . mc/edit-lines)
   ("C-c l l" . mc/mark-all-words-like-this)))
#+END_SRC

** Parentheses and delimiters

When programming you use a lot of =()= or ={}= so I pulled out a nice
configuration to manage this delimiters.

*** Highlighing

#+BEGIN_SRC emacs-lisp
(use-package show-paren-mode
  :ensure nil
  :init
  (show-paren-mode t))

(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'rainbow-delimiters-mismatched-face nil
                        :foreground zenburn-red-2)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground zenburn-red-2)))
#+END_SRC

Also I use =smartparens= to be sure I don't forget to close 'em! It
takes some time to be used to it though.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("C-c l DEL" . sp-unwrap-sexp)
   ("C-c l m" . sp-mark-sexp)))

(use-package smartparens-config
  :ensure nil
  :after smartparens
  :init
  (smartparens-global-mode)
  (sp-pair "{{" "}}")
  (sp-pair "[[" "]]"))
#+END_SRC

** Project management

I love =projectile= and I think its the best project management tool
you'll ever need in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" (elnawe::get-configurations-folder))
   projectile-completition-system 'ivy
   projectile-enable-caching t
   projectile-keymap-prefix (kbd "C-c p")
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" (elnawe::get-configurations-folder))
   projectile-mode-line '(:eval (projectile-project-name))
   projectile-switch-project-action 'projectile-find-file)
  (projectile-global-mode))
#+END_SRC

** Search and replace

Better search and replace with =anzu=. This is a known =vim= package
that [[https://github.com/syohex/emacs-anzu][syohex]] ported to Emacs.
Also, here I've some =isearch= configuration to work with better regexp
searching mechanics.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind
  (([remap query-replace] . anzu-query-replace-regexp))
  :init
  (global-anzu-mode)
  :config
  (setq
   anzu-cons-mode-line-p nil)

  (zenburn-with-color-variables
    (set-face-attribute 'anzu-replace-highlight nil
                        :background zenburn-red-4
                        :foreground zenburn-red+1)
    (set-face-attribute 'anzu-replace-to nil
                        :background zenburn-green-1
                        :foreground zenburn-green+4)))

(use-package isearch
  :ensure nil
  :bind
  (:map isearch-mode-map
        ("M-j" . isearch-ring-advance)
        ("M-k" . isearch-ring-retreat)
        :map minibuffer-local-isearch-map
        ("M-j" . next-history-element)
        ("M-k" . previous-history-element))
  :config
  (setq
   isearch-allow-scroll t
   lazy-highlight-cleanup nil
   lazy-highlight-initial-delay 0)
  (zenburn-with-color-variables
    (set-face-attribute 'isearch nil
                        :background zenburn-blue
                        :foreground zenburn-fg)
    (set-face-attribute 'isearch-lazy-highlight-face nil
                        :background zenburn-blue-5
                        :foreground zenburn-blue)))
#+END_SRC

** Tree view

I don't use this often but it's a good thing to have in hand if I need
to find a file by its folder.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind
  (([f6] . neotree-toggle)
   ("M-2" . neotree-toggle)
   :map neotree-mode-map
   ("<return>" . neotree-enter)
   ("c" . neotree-create-node)
   ("d" . neotree-delete-node)
   ("j" . neotree-next-line)
   ("k" . neotree-previous-line)
   ("r" . neotree-rename-node)
   ("s" . neotree-dir))
  :config
  (setq
   neo-autorefresh t
   neo-force-change-root t
   neo-smart-open t
   neo-theme (if (display-graphic-p) 'icons 'arrow)
   neo-vc-integration '(face char)
   neo-window-width 50
   neo-window-position 'right)

  (zenburn-with-color-variables
    (set-face-attribute 'neo-vc-edited-face nil
                        :foreground zenburn-yellow-1)
    (set-face-attribute 'neo-vc-added-face nil
                        :foreground zenburn-green-1)))
#+END_SRC

** Version Control

Magit provides everything I need when working with Version Control, all
within Emacs. Also, it merges very well with my =mode-line=
configuration.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :preface
  (defun elnawe::magit/display-buffer-same (buffer)
    "Display most magit popups in the current buffer."
    (display-buffer
     buffer
     (cond ((and (derived-mode-p 'magit-mode)
                 (eq (with-current-buffer buffer major-mode) 'magit-status-mode))
            nil)
           ((memq (with-current-buffer buffer major-mode)
                  '(magit-process-mode
                    magit-revision-mode
                    magit-diff-mode
                    magit-stash-mode))
            nil)
           (t '(display-buffer-same-window)))))
  :config
  (setq
   magit-display-buffer-function #'elnawe::magit/display-buffer-same
   magit-diff-highlight-hunk-body nil
   magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside
     magit-diff-highlight-hunk-region-using-face)
   magit-popup-display-buffer-action '((display-buffer-same-window))
   magit-refs-show-commit-count 'all
   magit-section-show-child-count t)
  (delight
   '((magit-diff-mode "Git Diff")
     (magit-log-mode "Git Log")
     (magit-popup-mode "Magit Popup")
     (magit-status-mode "Git Status")))
  (set-face-attribute 'magit-diff-file-heading-highlight nil :background nil)
  (set-face-attribute 'magit-diff-hunk-region nil :inherit 'region)
  (set-face-attribute 'magit-popup-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-highlight nil :background nil)
  (zenburn-with-color-variables
    (set-face-attribute 'magit-diff-added nil
                        :background nil
                        :foreground zenburn-green+3)
    (set-face-attribute 'magit-diff-removed nil
                        :background nil
                        :foreground zenburn-red)))
#+END_SRC

** Whitespaces

Highlight trailing whitespaces, tabs and empty lines. Also remove them
when saving the file.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :demand t
  :ensure nil
  :init
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (add-hook 'prog-mode-hook #'whitespace-turn-on)
  (add-hook 'text-mode-hook #'whitespace-turn-on)
  :config
  (setq whitespace-style '(face tab trailing)))
#+END_SRC

** Word highlighting

Highlight words like `TODO`, `FIXME` or `BUG` when in programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 font-lock-warning-face t)))))
#+END_SRC

* Major features

** Help

One great feature of Emacs is the self-documentation. This little
configuration makes navigating through it a little bit easier.

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("j" . next-line)
        ("k" . previous-line)
        ("q" . kill-buffer-and-window)
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Mode-line

This is where I spend most of the time. I love customization and Emacs
bring me something like this to play. I use =spaceline= to customize my
mode-line, but I'm positive that in some future I will move back to
=powerline=.

*** Delight

This package allows me to rename the major/minor modes "lightes", so
they look more like a compact and descriptive string instead of the
awful name that they already have (I'm looking at you =js2-mode=).
*NOTE*: Since this package is installed as main dependency, this piece
of code is merely for configuration.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure nil
  :config
  (defadvice powerline-major-mode (around delight-powerline-major-mode activate)
    (let ((inhibit-mode-name-delight nil)) ad-do-it)))
#+END_SRC

*** Forecast

Not going outside too much but always know what is happening out there.

#+BEGIN_SRC emacs-lisp
(use-package forecast
  :after spaceline
  :config
  (setq forecast-rain-symbol "\xf043")
  (progn
    (run-at-time elnawe/start-time-seconds nil
                 (lambda ()
                   (forecast--load-data (lambda ()
                                          (forecast--make-buffer "*Weather Forecast*"))))))

  (run-at-time t elnawe/update-time-seconds (lambda ()
                                              (forecast-refresh))))
#+END_SRC

*** Icons

A fancy looking mode-line is fancy! *Note*: Weather icons
[[Define segments][here]]

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :init
  (defun elnawe::ati/get-icon (NAME)
    "Uses `NAME' to retrieve an icon from `ati/icons-alist'"
    (cdr
     (assoc NAME ati/icons-alist)))

  (if (not elnawe/icons-enabled)
      (setq ati/icons-alist '((clock . "time ")
                              (git . "git ")
                              (spotify . "listening ")
                              (twitter . "twitter ")
                              (web . "web ")))
    (setq ati/icons-alist '((clock . "\xf017 ")
                            (git . "\xe907 ")
                            (spotify . "\xf1bc")
                            (twitter . "\xf099 ")
                            (web . "\xf0c1 ")))))
#+END_SRC

*** Spaceline

**** Setup

First, download Spaceline if doesn't exist and override
=mode-line-format=.

#+BEGIN_SRC emacs-lisp
(use-package spaceline
  :init
  (require 'spaceline-config)
  (setq-default mode-line-format '("%e" (:eval (spaceline-ml-main)))))
#+END_SRC

**** Define segments

Useful macro to programatically put faces to my segments.

#+BEGIN_SRC emacs-lisp
(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))
#+END_SRC

Better buffer-id without mouseover and highlighting. I use the spaceline
=highlight-face= for this segment.

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment elnawe::buffer-id-segment
  (buffer-name))
#+END_SRC

The time in my spaceline is super-important because I mostly use Emacs
in fullscreen mode.

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment elnawe::time-segment
  (concat
   (with-face (elnawe::ati/get-icon 'clock) '(:foreground "#DCA3A3"))
   (format-time-string "%H:%M" (current-time))))
#+END_SRC

Weather in Emacs? Yes, you can do it with =forecast= which is a great
package. Check also my [[Forecast]] configuration.

#+BEGIN_SRC emacs-lisp
(setq elnawe/forecast-icons-colors '(("clear-day" "\xf185 " :foreground "#F0DFAF")
                                     ("clear-night" "\xf186 " :foreground "#6F6F6F")
                                     ("cloudy" "\xf0c2 " :foreground "#6F6F6F")
                                     ("fog" "\xf04d " :foreground "#6F6F6F")
                                     ("partly-cloudy-day" "\xf0c2 " :foreground "#D0BF8F")
                                     ("partly-cloudy-night" "\xf0c2 " :foreground "#6F6F6F")
                                     ("rain" "\xf043 " :foreground "#94BFF3")
                                     ("wind" "\xf1d9 " :foreground "#DCDCCC")))

(defun elnawe::forecast/get-metadata ()
  "Get a value from `elnawe/forecast-icons-colors' depending on
what `currently.icon' has (which is the same as current weather
outside)'"
  (assoc
   (forecast--assoca '(currently icon) forecast--data)
   elnawe/forecast-icons-colors))

(spaceline-define-segment elnawe::forecast-segment
  "Show the current temperature"
  (when (bound-and-true-p forecast--buffer)
    (propertize
     (concat
      (with-face
       (if elnawe/icons-enabled (car (cdr (elnawe::forecast/get-metadata))) (car (elnawe::forecast/get-metadata)))
       (cdr (cdr (elnawe::forecast/get-metadata))))
      " "
      (forecast--temperature-string)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(spaceline-define-segment elnawe::version-control-segment
  "Minimal version control information."
  (when (fboundp 'magit-get-current-branch)
    (concat
     (with-face (elnawe::ati/get-icon 'git) '(:foreground "#DFAF8F"))
     (magit-get-current-branch)
     (powerline-raw
      (when (buffer-file-name)
        (pcase (vc-state (buffer-file-name))
          (`up-to-date "")
          (`edited " *")))))))
#+END_SRC

**** Configuration

Setup the actual configuration

#+BEGIN_SRC emacs-lisp
(setq
 powerline-default-separator 'arrow
 powerline-height 25
 spaceline-highlight-face-func 'spaceline-highlight-face-modified
 spaceline-separator-dir-left '(left . left)
 spaceline-separator-dir-right '(right . right))

(spaceline-install
  '((major-mode :face highlight-face)
    (elnawe::time-segment)
    (elnawe::version-control-segment)
    (elnawe::forecast-segment))
  '((anzu :when active)
    (selection-info :when mark-active)
    (projectile-root)
    (line-column :priority 13)
    ((hud buffer-position))
    (elnawe::buffer-id-segment :face highlight-face :priority 13)))
#+END_SRC

**** Theme

And there's some theme configuration going on.

#+BEGIN_SRC emacs-lisp
(zenburn-with-color-variables
  (set-face-attribute 'mode-line nil
                      :background zenburn-bg-1
                      :box nil
                      :foreground zenburn-fg)
  (set-face-attribute 'powerline-active1 nil
                      :background zenburn-bg-1
                      :foreground zenburn-fg)
  (set-face-attribute 'powerline-active2 nil
                      :background zenburn-bg-05)
  (set-face-attribute 'mode-line-inactive nil
                      :background zenburn-bg-2
                      :box nil
                      :foreground zenburn-bg+3)
  (set-face-attribute 'powerline-inactive1 nil
                      :background zenburn-bg-2
                      :foreground zenburn-bg+3)
  (set-face-attribute 'powerline-inactive2 nil
                      :background zenburn-bg-1)
  (set-face-attribute 'spaceline-flycheck-error nil
                      :foreground zenburn-red)
  (set-face-attribute 'spaceline-flycheck-info nil
                      :foreground zenburn-blue+1)
  (set-face-attribute 'spaceline-flycheck-warning nil
                      :foreground zenburn-orange)
  (set-face-attribute 'spaceline-highlight-face nil
                      :background zenburn-yellow
                      :foreground zenburn-bg-1)
  (set-face-attribute 'spaceline-modified nil
                      :background zenburn-red-1
                      :foreground zenburn-bg-1)
  (set-face-attribute 'spaceline-read-only nil
                      :background zenburn-blue-1
                      :foreground zenburn-bg-1)
  (set-face-attribute 'spaceline-unmodified nil
                      :background zenburn-green-1
                      :foreground zenburn-bg-1))
#+END_SRC
