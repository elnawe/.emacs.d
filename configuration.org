#+TITLE: Configuration.org - A literate programming for my Emacs configuration
#+AUTHOR: Nahuel Jesús Sacchetti
#+OPTIONS: toc:3

* Introduction

Welcome to my configuration file for GNU Emacs.

#+BEGIN_QUOTE
Emacs was originally an extensible text editor written by Richard
Stallman, but it became a way of life and a religion. Emacs is love,
Emacs is life.
#+END_QUOTE

This is my third version of the configuration file. I've been learning a
lot lately and I felt the responsability of updating this file to match
all my new "standards" and also to keep those really clear.

** =TODOs=

This section is inteded to have all the things I want =todo= but I do
not have time to right now.

** Personal information

#+BEGIN_SRC emacs-lisp
(setq
 user-full-name "Nahuel Jesús Sacchetti"
 user-mail-address "nahueljsacchetti@gmail.com")
#+END_SRC

* Bootstrapping my Emacs

It's nice to have your Emacs /standarided/ and feel that you're using
the same configuration everywhere.

** Custom variables

#+BEGIN_SRC emacs-lisp
(defvar elnawe/font-family "DejaVu Sans Mono-12" "Font used for theming")
(defvar elnawe/font-size 100 "Default font size")
(defvar elnawe/font-size-title 150 "Font size used in titles")
(defvar elnawe/start-time-seconds 20 "Time in seconds to start a mini application")
(defvar elnawe/update-time-seconds 1800 "Time in seconds to update/refresh mini applications")
(defvar elnawe/icons-enabled t "Show/hide special icons. Most of them used in mode-line")
#+END_SRC

** Make Emacs faster

Collect garbage when focus out your Emacs.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** My better-defaults

Since I've been using Emacs I noticed some actual default variables are
not the best fit for me. I managed to put together a list of my better
defaults and they are here:

#+BEGIN_SRC emacs-lisp
(setq-default
 cursor-in-non-selected-windows t                          ; Hide cursor in inactive windows
 delete-by-moving-to-trash t                               ; Move file to trash instead of removing it
 display-time-default-load-average nil                     ; Don't display load avereage
 display-time-format "%H:%M"                               ; Format the time string
 fill-column 72                                            ; Width before automatic line breaks
 frame-title-format "Emacs"                                ; Change frame title to "Emacs"
 help-window-select t                                      ; Focus help windows when opened
 indent-tabs-mode nil                                      ; Use spaces for indentation
 inhibit-startup-screen t                                  ; Disable the startup window
 initial-scratch-message ""                                ; Empty *scratch* buffer
 left-margin-width 1 right-margin-width 0                  ; Add left and right margins
 view-read-only t                                          ; View the readonly files
 ring-bell-function 'ignore                                ; Ignore any kind of bell notifications
 scroll-conservatively most-positive-fixnum                ; Always scroll by one line
 scroll-margin 10                                          ; Add a margin when scrolling vertically
 select-enable-clipboard t                                 ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                             ; End sentence when dot and space
 show-trailing-whitespace nil                              ; Display trailing whitespaces
 split-height-threshold 1000                               ; Enable vertical splitting
 split-width-threshold nil                                 ; Disable horizontal splitting
 tab-width 4                                               ; Set indentation width
 truncate-lines t                                          ; Disable truncate lines
 uniquify-buffer-name-style 'forward                       ; Make buffer names unique
 visible-bell nil                                          ; Replace the alarm to an audible one
 window-combination-resize t                               ; Resize window proportionally
 x-stretch-cursor t)                                       ; Give cursor glyph width
(delete-selection-mode)                                    ; Replace region when inserting text
(display-time-mode)                                        ; Enable time-mode in mode-line
(fset 'yes-or-no-p 'y-or-n-p)                              ; Alias y/n prompts to yes/no
(global-auto-revert-mode)                                  ; Refresh buffer if changed outside Emacs
(global-hl-line-mode)                                      ; Highlight current line
(global-subword-mode)                                      ; Iterate through camelCase words
(menu-bar-mode 0)                                          ; Disable the menu bar
(tool-bar-mode 0)                                          ; Disable the tool-bar
(mouse-avoidance-mode 'none)                               ; Avoid mouse colission with point
(define-key global-map "\C-ci" #'elnawe::open-config-file) ; Binds `C-ci' to open the configuration
#+END_SRC

** Emacsclient and Job Control

Emacsclient opens a frame that runs over the Daemon instead of creating
a new instance. Here I just override the way that =C-x C-c= works to
prompt a question before closing the frame as I do when I use =emacs=.

Also, since I don't use =Job control mode= in my Terminal, i unbind the
=C-z= and =C-x C-z= command =(suspend-emacs)=.

#+BEGIN_SRC emacs-lisp
(defun elnawe::emacsclient/promt-before-closing-frame ()
  "Prompts before closing a frame with `C-x C-c' like `emacs' does"
  (interactive)
  (if (y-or-n-p "Are you sure you want to exit Emacs? ")
      (save-buffers-kill-terminal)))

(global-set-key (kbd "C-x C-c") #'elnawe::emacsclient/promt-before-closing-frame)
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+END_SRC

** Helpers

This is a set of helper functions that are used in this configuration.

#+BEGIN_SRC emacs-lisp
(defun elnawe::start-with-delay (FUNC)
  "Runs `FUNC' with a delay declared in
  `elnawe/start-time-seconds'. This function should be used to
  run smaller apps that are not crucial for Emacs to work"
  (run-at-time elnawe/start-time-seconds nil (funcall FUNC)))

(defun elnawe::load-package-dir (PACKAGE)
  "Returns package `PACKAGE' from /packages directory"
  (concat user-emacs-directory "packages/" PACKAGE))

(defun elnawe::open-config-file ()
  "Opens the config file `configuration.org' on a new buffer"
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

(defun elnawe::get-configurations-folder ()
  "Returns the folder where configuration files are stored"
  (concat (getenv "HOME") "/.emacs.config"))

(defun elnawe::kill-current-buffer ()
  "Kill current buffer without prompting"
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC

** OS specific configurations

Because I use Emacs everywhere, I need some extra configurations.

*** MacOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   elnawe/font-family "DejaVu Sans Mono-15"          ; Change font-family
   exec-path (append exec-path '("/usr/local/bin"))  ; Add Homebrew path
   ns-command-modifier 'meta                         ; Meta key is Command
   ns-option-modifier nil                            ; I use Alt/Option to expand my keyboard layout
   ns-right-option-modifier 'super                   ; Never use right Alt key so I can use it as Super key
   ns-use-srgb-colorspace nil))                      ; Using different colorspace for Mac
#+END_SRC

Intializing env inside Emacs

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config (exec-path-from-shell-initialize))
#+END_SRC

*** TOS

I'm a pretty big fan of Terminal Operating System and my desktop (and
one of my laptops) has a clean ArchLinux installed with no visual
desktop o GUI. These configurations are needed to ensure that my Emacs
works well on those boxes!

#+BEGIN_SRC emacs-lisp
(when (not window-system)
  (setq-default
   elnawe/icons-enabled nil)
  (global-hl-line-mode -1))
#+END_SRC

** Load =.custom.el=

You can use the customization interface that Emacs provide but when you
edit something, =init.el= is overriden with the new configuration. To
fix this, I move the Emacs customization changes to a new file and then
I load it.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =secrets=

This loads a collection of secret and sensible information. I keep this
file separated to maintain privacy.

#+BEGIN_SRC emacs-lisp
(load "~/.elnawe.secrets/.emacs" t)
#+END_SRC

* Theming

** Zenburn

It's the best thing that happened to me since I started programming. I'm
just in love with *Zenburn*. By the way, everything I use looks like
Zenburn. [[https://github.com/bbatsov/zenburn-emacs][This]] is the theme
I use.

#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
  :init
  (load-theme 'zenburn t)
  :config
  (set-face-attribute 'font-lock-comment-face nil :italic nil)

  (zenburn-with-color-variables
    (set-face-attribute 'button nil
                        :foreground zenburn-yellow-2)
    (set-face-attribute 'default nil
                        :background zenburn-bg-05
                        :height elnawe/font-size
                        :font elnawe/font-family)
    (set-face-attribute 'font-lock-warning-face nil
                        :foreground zenburn-green+2
                        :underline '(:style wave)
                        :weight 'bold)
    (set-face-attribute 'help-argument-name nil
                        :foreground zenburn-orange
                        :italic nil)
    (set-face-attribute 'hl-line nil
                        :background zenburn-bg+1)
    (set-face-attribute 'header-line nil
                        :background zenburn-bg-1
                        :box nil)
    (set-face-attribute 'region nil
                        :background zenburn-bg+1
                        :distant-foreground zenburn-orange
                        :foreground zenburn-orange)
    (set-face-attribute 'vertical-border nil
                        :foreground zenburn-green-1)

    (mapc
     (lambda (face)
       (when (eq (face-attribute face :background) zenburn-bg)
         (set-face-attribute face nil
                             :background 'unspecified)))
     (face-list))))
#+END_SRC

* Emacs everyday

** Agenda

When you use Emacs for a while you understand that you can not just edit
code, create presentations or write quite beautiful tables and lists.
You can also have a very nice =TODO= list synched all the time with your
server that acts as your agenda and note-taking. This is actually nice.

*** Directories

#+BEGIN_SRC emacs-lisp
(setq-default
 org-directory "~/Dropbox/orgs")

(defun elnawe::org/file-path (FILENAME)
  "Returns the absolute path of a given `FILENAME` with default `org-directory`"
  (concat (file-name-as-directory org-directory) FILENAME))

(setq
 org-archive-location (concat (elnawe::org/file-path "archive.org") ":: From %s")
 org-index-file (elnawe::org/file-path "index.org"))
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp
(defun elnawe::org/mark-done-and-archive ()
  "Mark the state of an org-mode item as `DONE' and archive it"
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(define-key global-map "\C-ca" 'org-agenda)
(define-key global-map "\C-cc" 'org-capture)
(define-key org-mode-map (kbd "C-c C-x C-s") 'elnawe::org/mark-done-and-archive)
#+END_SRC

*** New captures

#+BEGIN_SRC emacs-lisp
(setq
 org-agenda-files (list org-index-file)
 org-capture-templates '(("i" "Ideas"
                          entry
                          (file (elnawe::org/file-path "ideas.org"))
                          "* %?\n")
                         ("t" "TODO Item"
                          entry
                          (file+headline org-index-file "Inbox")
                          "* TODO %?\n"))
 org-log-done 'time)
#+END_SRC

** Backup copies

Manage the backup copies. Always keeping them but save them inside Emacs
directory.

#+BEGIN_SRC emacs-lisp
(setq-default
 backup-by-copying t
 backup-directory-alist '(("." . "~/.emacs.config/saves"))
 delete-old-versions 'never
 make-backup-files t
 version-control 'numbered)
#+END_SRC

** Development notes

I found that Emacs + =org-mode= are great for note-taking. I like to
take notes of my TIL stuff and for things related to development that it
will be useful to read after a while. More like, memory refreshing
things.

#+BEGIN_SRC emacs-lisp
(add-to-list
 'org-capture-templates
 '("j" "JavaScript Development Notes"
   entry
   (file+headline (elnawe::org/file-path "dev-notes.org") "JavaScript")
   "
,* %^{Title}
%?"))

(add-to-list
 'org-capture-templates
 '("l" "Linux Notes"
   entry
   (file+headline (elnawe::org/file-path "dev-notes.org") "JavaScript")
   "
,* %^{Title}
%?"))
#+END_SRC

** Dim other buffers

Automatically dim my other opened buffers. This help me focus on the one
that is being reading/modifying.

#+BEGIN_SRC emacs-lisp
(use-package auto-dim-other-buffers
  :init
  (auto-dim-other-buffers-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'auto-dim-other-buffers-face nil
                        :background zenburn-bg-1)))
#+END_SRC

** Fill paragraph automatically

When I'm in =text-mode= I want my paragraph to be just the lenght of my
ruler. Also, I don't want to use =M-q= to adjust it by myself, because
Emacs allow me to do it automatically!

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :init
  (add-hook 'text-mode-hook #'turn-on-auto-fill))
#+END_SRC

** =ivy-mode= for minibuffer completition

First I used =helm= but it felt slow. Then I moved to the built-in
=ido-mode= and, though it worked great, I wanted to try =ivy= and after
searching the Internet I found it very useful!

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :init
  (ivy-mode 1)
  :config
  (setq
   enable-recursive-minibuffers t
   ivy-count-format "[%d/%d] "
   ivy-display-style 'fancy
   ivy-extra-directories nil
   ivy-use-virtual-buffers t))

(use-package counsel)

(use-package swiper)
#+END_SRC

** Navigation

Navigation its an important thing in Emacs, specially when you just use
the keyboard.

*** Beginning of line

This is a better =move-beginning-of-line= function that also goes to
beginning after indentation.

#+BEGIN_SRC emacs-lisp
(defun elnawe::dwin/beginning-of-line ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))

(global-set-key [remap move-beginning-of-line] #'elnawe::dwin/beginning-of-line)
#+END_SRC

*** Disable mouse

#+BEGIN_SRC emacs-lisp
(use-package disable-mouse
  :init
  (global-disable-mouse-mode))
#+END_SRC

*** Kill Current Buffer

Assume I want to kill buffer with =C-x k= without asking

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'elnawe::kill-current-buffer)
#+END_SRC

*** Vi-like navigation

I tend to use the terminal a lot and most of the programs you use there
uses a vi-like navigation. You just get used to it.

#+BEGIN_SRC emacs-lisp
(add-hook 'read-only-mode-hook
          (lambda ()
            (define-key view-mode-map "J" #'scroll-up-line)
            (define-key view-mode-map "K" #'scroll-down-line)
            (define-key view-mode-map "j" #'next-line)
            (define-key view-mode-map "k" #'previous-line)
            (define-key view-mode-map "l" #'right-char)
            (define-key view-mode-map "h" #'left-char)
            (define-key view-mode-map "i" #'read-only-mode)))

(define-key global-map [f4] #'read-only-mode)
(define-key global-map "\M-3" #'read-only-mode)
#+END_SRC

** Pomodoro

Time tracking for efficiency in any aspect. The Pomodoro technique is a
well known way to maximize the time of your activities.

#+BEGIN_SRC emacs-lisp
(use-package org-pomodoro
  :after org
  :preface
  (defun elnawe::open-tasks-file ()
    "Opens the tasks file on a new buffer"
    (interactive)
    (split-window-below)
    (balance-windows)
    (other-window 1)
    (find-file "~/Dropbox/orgs/tasks.org"))
  :bind
  ("C-c t" . elnawe::open-tasks-file)
  :config
  (setq org-pomodoro-format "%s")
  (add-to-list
   'org-capture-templates
   '("p" "Pomodoro"
     entry
     (file (elnawe::org/file-path "tasks.org"))
     "
,* %^{Task description}
%?"
     )))
#+END_SRC

** Restart Emacs

When I am updating or changing some configuration on my Emacs I like to
restart it to clean up everything I removed. There's an excellent
package to do that and it's called =restart-emacs=. Instead of =C-x C-c=
(quit-emacs) I use =C-x C-M-c= to restart it.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :bind
  ("C-x C-M-c" . restart-emacs))
#+END_SRC

** Window management

Window management is something you have to do in Emacs, and you'll have
to do it a lot. This is a great set of configurations to make it look
and feel easy to do.

*** Destkop

For Emacs =desktop= is the working session you left off when closing it.
I like to keep it always there so I can continue from that point.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :ensure nil
  :demand t
  :config
  (desktop-save-mode))
#+END_SRC

*** Moving through windows

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-c m h". windmove-left)
   ("C-c m l". windmove-right)
   ("C-c m k". windmove-up)
   ("C-c m j". windmove-down)
   ("C-c m o" . other-window)))
#+END_SRC

*** Splitting windows

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/create-bottom-and-switch ()
  "Creates a new window to the bottom and then switch to it"
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun elnawe::window/create-right-and-switch ()
  "Creates a new window to the right and then switch to it"
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'elnawe::window/create-bottom-and-switch)
(global-set-key (kbd "C-x 3") 'elnawe::window/create-right-and-switch)
(global-set-key (kbd "C-x `") 'ivy-switch-buffer-other-window)
#+END_SRC

*** Temporal buffers

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/split-vertically-for-temp-buffers ()
  (when (one-window-p t)
    (split-window-vertically)))

(add-hook 'temp-buffer-window-setup-hook
          'elnawe::window/split-vertically-for-temp-buffers)
#+END_SRC

*** Undo/redo configurations

Sometimes you close windows or change their layout without meaning to.
Thanks to Emacs =winner= mode helps me to go back if that happens.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :defer 1
  :bind
  (("C-c b M-h" . winner-undo)
   ("C-c b M-l" . winner-redo))
  :init
  (winner-mode))
#+END_SRC

* Programming

I use Emacs for everything, even code. I like to keep it good looking
but really functional.

** Auto-completition

I'm not a very big fan of auto-complete my words but sometimes it's a
bit helpful.

#+BEGIN_SRC emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook #'global-company-mode)
  :config
  (setq
   company-idle-delay 0.3
   company-minimum-prefix-length 3
   company-tooltip-align-annotations t))
#+END_SRC

** Auto-indent as you write

Helps me to maintain my code aligned with aggresive indentation.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :init
  (aggressive-indent-global-mode))
#+END_SRC

** Expanding code

Using built-in =hippie-exp= package to manage expansions. This is a
DWIM-like (Do What I Mean) expansion, trying to be smart depending on
its context. Mostly you can use any kind of expansion with =<C-return>=

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :bind
  ((:map emmet-mode-keymap
        ("<C-return>" . nil)
        ("C-M-<left>" . nil)
        ("C-M-<right>" . nil)
        ("C-c w" . nil)))
  :init
  (add-hook 'css-mode-hook #'emmet-mode)
  (add-hook 'html-mode-hook #'emmet-mode)
  (add-hook 'rjsx-mode-hook #'emmet-mode)
  :config
  (setq emmet-move-cursor-between-quote t))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun elnawe::emmet/try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
    (interactive "P")
    (when emmet-mode (emmet-expand-line args)))
  :bind
  (("<C-return>" . hippie-expand)
   ("M-RET" . hippie-expand))
  :config
  (setq-default
   hippie-expand-try-functions-list '(elnawe::emmet/try-expand-line)
   hippie-expand-verbose nil))
#+END_SRC

** Go to definition

When working on big projects *go to definition* it's a must. =dumb-jump=
helps me with that.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :bind
  (("C-c l g" . dumb-jump-go)
   ("C-c l n" . dumb-jump-go-prefer-external-other-window))
  :init
  (dumb-jump-mode 1))
#+END_SRC

** Kill line or region

Instead of the default =C-w=, this function overrides that feature to
cut the line where you at if there's no region selected.

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead"
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

** Languages

*** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure nil
    :config
    (setq-default css-indent-offset 4))

  (use-package scss-mode
    :ensure nil
    :mode ("\\.sass\\'" "\\.scss\\'"))
#+END_SRC

*** HTML

Using HTML mode defined in =sgml-mode.el=

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :ensure nil
  :init
  (add-hook 'html-mode-hook #'sgml-electric-tag-pair-mode)
  (add-hook 'html-mode-hook #'sgml-name-8bit-mode)
  :config
  (setq sgml-basic-offset 4))
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp
(use-package js
  :init
  (add-hook 'js-mode #'js2-mode))

(use-package js2-mode
  :mode ("\\.js\\'")
  :config
  (setq js-indent-level 4))

(use-package json-mode
  :init
  (add-hook 'json-mode-hook
            (lambda ()
              (make-local-variable 'js-indent-level)
              (setq js-indent-level 2))))

(use-package ng2-mode
  :mode ("/futbol-club/.*\\.ts" "/futbol-club/.*\\.html"))

(use-package rjsx-mode
  :mode ("/swa-ui-app/.*\\.js$")
  :config
  (setq js-indent-level 4))

(use-package tide)

(use-package typescript-mode
  :init
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (eldoc-mode 1)
    (tide-hl-identifier-mode))
  (add-hook 'before-save-hook #'tide-format-before-save)
  (add-hook 'typescript-mode-hook #'setup-tide-mode)
  :config
  (setq company-tooltip-align-annotations t))
#+END_SRC

*** Markdown

Mostly I use =org-mode=, but sometimes you need to write down your
README files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode ("INSTALL\\'" "LICENSE\\'" "README\\'" "\\.md\\'" "\\.markdown\\'")
    :config
    (setq
     markdown-asymmetric-header t
     markdown-split-window-direction 'right))
#+END_SRC

*** Org

My whole configuration is written in =org-mode=. I also write all my
TODO lists in Org. This is a powerful tool and I'm not the best user.
I'm learning though. Also, I'm working with [[Agenda][=org-agenda=]]

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :init
  (add-hook 'org-mode-hook #'org-sticky-header-mode)
  (add-hook 'org-mode-hook #'org-bullets-mode)
  :config
  (setq
   org-descriptive-links nil
   org-ellipsis "\u21b4"
   org-startup-folded nil
   org-startup-truncated nil))

(use-package org-src
  :ensure nil
  :after org
  :config
  (setq
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-fontify-natively t
   org-src-tab-acts-natively t
   org-src-window-setup 'current-window))

(use-package org-sticky-header
  :config
  (setq
   org-sticky-header-full-path 'full
   org-sticky-header-outline-path-separator " > "))
#+END_SRC

** Multiple cursors

I actually like some of the features that modern IDE provides, like
multiple cursor editing. It's great that Emacs can do that as well!

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C-c l e" . mc/edit-lines)
   ("C-c l l" . mc/mark-all-words-like-this)))
#+END_SRC

** Parentheses and delimiters

When programming you use a lot of =()= or ={}= so I pulled out a nice
configuration to manage this delimiters.

*** Highlighing

#+BEGIN_SRC emacs-lisp
(use-package show-paren-mode
  :ensure nil
  :init
  (show-paren-mode t))

(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  :config
  (zenburn-with-color-variables
    (set-face-attribute 'rainbow-delimiters-mismatched-face nil
                        :foreground zenburn-red-2)
    (set-face-attribute 'rainbow-delimiters-unmatched-face nil
                        :foreground zenburn-red-2)))
#+END_SRC

Also I use =smartparens= to be sure I don't forget to close 'em! It
takes some time to be used to it though.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :bind
  (("C-c l DEL" . sp-unwrap-sexp)
   ("C-c l m" . sp-mark-sexp)))

(use-package smartparens-config
  :ensure nil
  :after smartparens
  :init
  (smartparens-global-mode)
  (sp-pair "{{" "}}")
  (sp-pair "[[" "]]"))
#+END_SRC

** Project management

I love =projectile= and I think its the best project management tool
you'll ever need in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" (elnawe::get-configurations-folder))
   projectile-completition-system 'ivy
   projectile-enable-caching t
   projectile-keymap-prefix (kbd "C-c p")
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" (elnawe::get-configurations-folder))
   projectile-mode-line '(:eval (projectile-project-name))
   projectile-switch-project-action 'projectile-find-file)
  (projectile-global-mode))

(use-package counsel-projectile
  :init
  (counsel-projectile-on))
#+END_SRC

** Search and replace

Better search and replace with =anzu=. This is a known =vim= package
that [[https://github.com/syohex/emacs-anzu][syohex]] ported to Emacs.
Also, here I've some =isearch= configuration to work with better regexp
searching mechanics.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :bind
  (([remap query-replace] . anzu-query-replace-regexp))
  :init
  (global-anzu-mode)
  :config
  (setq
   anzu-cons-mode-line-p nil)

  (zenburn-with-color-variables
    (set-face-attribute 'anzu-mode-line nil
                        :foreground zenburn-bg-1)
    (set-face-attribute 'anzu-mode-line-no-match nil
                        :foreground zenburn-red-4)
    (set-face-attribute 'anzu-replace-highlight nil
                        :background zenburn-red-4
                        :foreground zenburn-red+1)
    (set-face-attribute 'anzu-replace-to nil
                        :background zenburn-green-1
                        :foreground zenburn-green+4)))

(use-package isearch
  :ensure nil
  :bind
  (:map isearch-mode-map
        ("M-j" . isearch-ring-advance)
        ("M-k" . isearch-ring-retreat)
        :map minibuffer-local-isearch-map
        ("M-j" . next-history-element)
        ("M-k" . previous-history-element))
  :config
  (setq
   isearch-allow-scroll t
   lazy-highlight-cleanup nil
   lazy-highlight-initial-delay 0)
  (zenburn-with-color-variables
    (set-face-attribute 'isearch nil
                        :background zenburn-blue
                        :foreground zenburn-fg)
    (set-face-attribute 'isearch-lazy-highlight-face nil
                        :background zenburn-blue-5
                        :foreground zenburn-blue)))
#+END_SRC

** Snippets

I use snippets for blog posting and email sending.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet)
#+END_SRC

** Tree view

I don't use this often but it's a good thing to have in hand if I need
to find a file by its folder.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind
  (([f6] . neotree-toggle)
   ("M-2" . neotree-toggle)
   :map neotree-mode-map
   ("<return>" . neotree-enter)
   ("c" . neotree-create-node)
   ("d" . neotree-delete-node)
   ("j" . neotree-next-line)
   ("k" . neotree-previous-line)
   ("r" . neotree-rename-node)
   ("s" . neotree-dir))
  :config
  (setq
   neo-autorefresh t
   neo-force-change-root t
   neo-smart-open t
   neo-theme (if (display-graphic-p) 'icons 'arrow)
   neo-vc-integration '(face char)
   neo-window-width 50
   neo-window-position 'right)

  (zenburn-with-color-variables
    (set-face-attribute 'neo-vc-edited-face nil
                        :foreground zenburn-yellow-1)
    (set-face-attribute 'neo-vc-added-face nil
                        :foreground zenburn-green-1)))
#+END_SRC

** Version Control

Magit provides everything I need when working with Version Control, all
within Emacs. Also, it merges very well with my =mode-line=
configuration.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :preface
  (defun elnawe::magit/display-buffer-same (buffer)
    "Display most magit popups in the current buffer."
    (display-buffer
     buffer
     (cond ((and (derived-mode-p 'magit-mode)
                 (eq (with-current-buffer buffer major-mode) 'magit-status-mode))
            nil)
           ((memq (with-current-buffer buffer major-mode)
                  '(magit-process-mode
                    magit-revision-mode
                    magit-diff-mode
                    magit-stash-mode))
            nil)
           (t '(display-buffer-same-window)))))
  :config
  (setq
   magit-display-buffer-function #'elnawe::magit/display-buffer-same
   magit-diff-highlight-hunk-body nil
   magit-diff-highlight-hunk-region-functions
   '(magit-diff-highlight-hunk-region-dim-outside
     magit-diff-highlight-hunk-region-using-face)
   magit-popup-display-buffer-action '((display-buffer-same-window))
   magit-refs-show-commit-count 'all
   magit-section-show-child-count t)
  (set-face-attribute 'magit-diff-file-heading-highlight nil :background nil)
  (set-face-attribute 'magit-diff-hunk-region nil :inherit 'region)
  (set-face-attribute 'magit-popup-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-heading nil :height elnawe/font-size-title)
  (set-face-attribute 'magit-section-highlight nil :background nil)
  (zenburn-with-color-variables
    (set-face-attribute 'magit-diff-added nil
                        :background nil
                        :foreground zenburn-green+3)
    (set-face-attribute 'magit-diff-removed nil
                        :background nil
                        :foreground zenburn-red)))
#+END_SRC

** Whitespaces

Highlight trailing whitespaces, tabs and empty lines. Also remove them
when saving the file.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :demand t
  :ensure nil
  :init
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (add-hook 'prog-mode-hook #'whitespace-turn-on)
  (add-hook 'text-mode-hook #'whitespace-turn-on)
  :config
  (setq whitespace-style '(face tab trailing)))
#+END_SRC

** Word highlighting

Highlight words like `TODO`, `FIXME` or `BUG` when in programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(FIXME\\|TODO\\|BUG\\):" 1 font-lock-warning-face t)))))
#+END_SRC

* Major features

** Help

One great feature of Emacs is the self-documentation. This little
configuration makes navigating through it a little bit easier.

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("j" . next-line)
        ("k" . previous-line)
        ("q" . kill-buffer-and-window)
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Mode-line

Started with =spaceline= which is a nice looking mode-line based on
=powerline= and extracted from =Spacemacs= but I always wanted to have
my own mode-line configuration. This is probably an always work in
progress.

#+BEGIN_SRC emacs-lisp
(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defun get-buffer-state ()
  (concat
   "["
   (cond
    (buffer-read-only "R")
    ((buffer-modified-p) (with-face "M" '(:foreground "#DCDCCC" :weight bold)))
    (t " "))
   "]"))

(setq-default
 mode-line-format
 (list
  " "
  '(:eval (get-buffer-state))
  (with-face " %b" '(:weight bold))
  "  %p L%02l C%02c"
  "    (%m) "
  '(:eval (projectile-project-name))
  " "
  '(:eval (anzu--update-mode-line))))

(zenburn-with-color-variables
  (set-face-attribute 'mode-line nil
                      :background zenburn-green-1
                      :box nil
                      :foreground zenburn-bg-1)
  (set-face-attribute 'mode-line-inactive nil
                      :background zenburn-bg
                      :box nil
                      :foreground zenburn-bg+3))
#+END_SRC
