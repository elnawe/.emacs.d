#+TITLE: Configuration.org - A literate programming for my Emacs configuration
#+AUTHOR: Nahuel Jesús Sacchetti
#+OPTIONS: toc:3

* Introduction

Welcome to my configuration file for GNU Emacs.

#+BEGIN_QUOTE
Emacs was originally an extensible text editor written by Richard
Stallman, but it became a way of life and a religion. Emacs is love,
Emacs is life.
#+END_QUOTE

This is my third version of the configuration file. I've been learning a
lot lately and I felt the responsability of updating this file to match
all my new "standards" and also to keep those really clear.

** =TODOs=

This section is inteded to have all the things I want =todo= but I do
not have time to right now.

** Personal Information

#+BEGIN_SRC emacs-lisp
(setq
 user-full-name "Nahuel Jesús Sacchetti"
 user-mail-address "nahueljsacchetti@gmail.com")
#+END_SRC

* Bootstrapping My Emacs

It's nice to have your Emacs /standarided/ and feel that you're using
the same configuration everywhere.

** Make Emacs Faster

Collect garbage when focus out your Emacs. At least that's what they say.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook #'garbage-collect)
#+END_SRC

** My Defaults

Since I've been using Emacs I noticed some actual default variables are
not the best fit for me. I managed to put together a list of my better
defaults and they are here:

#+BEGIN_SRC emacs-lisp
(setq-default
 cursor-in-non-selected-windows t                          ; Hide cursor in inactive windows
 delete-by-moving-to-trash t                               ; Move file to trash instead of removing it
 display-time-default-load-average nil                     ; Don't display load avereage
 display-time-format "%H:%M"                               ; Format the time string
 fill-column 72                                            ; Width before automatic line breaks
 frame-title-format "Emacs"                                ; Change frame title to "Emacs"
 help-window-select t                                      ; Focus help windows when opened
 indent-tabs-mode nil                                      ; Use spaces for indentation
 inhibit-startup-screen t                                  ; Disable the startup window
 initial-scratch-message ""                                ; Empty *scratch* buffer
 left-margin-width 1 right-margin-width 0                  ; Add left and right margins
 view-read-only t                                          ; View the readonly files
 ring-bell-function 'ignore                                ; Ignore any kind of bell notifications
 scroll-conservatively most-positive-fixnum                ; Always scroll by one line
 scroll-margin 10                                          ; Add a margin when scrolling vertically
 select-enable-clipboard t                                 ; Merge system's and Emacs' clipboard
 sentence-end-double-space nil                             ; End sentence when dot and space
 show-trailing-whitespace nil                              ; Display trailing whitespaces
 split-height-threshold 1000                               ; Enable vertical splitting
 split-width-threshold nil                                 ; Disable horizontal splitting
 tab-width 4                                               ; Set indentation width
 truncate-lines nil                                        ; Disable truncate lines
 uniquify-buffer-name-style 'forward                       ; Make buffer names unique
 visible-bell nil                                          ; Replace the alarm to an audible one
 window-combination-resize t                               ; Resize window proportionally
 x-stretch-cursor t)                                       ; Give cursor glyph width
(delete-selection-mode)                                    ; Replace region when inserting text
(display-time-mode)                                        ; Enable time-mode in mode-line
(fset 'yes-or-no-p 'y-or-n-p)                              ; Alias y/n prompts to yes/no
(global-auto-revert-mode)                                  ; Refresh buffer if changed outside Emacs
(global-subword-mode)                                      ; Iterate through camelCase words
(menu-bar-mode 0)                                          ; Disable the menu bar
(tool-bar-mode 0)                                          ; Disable the tool-bar
(mouse-avoidance-mode 'none)                               ; Avoid mouse colission with point
(define-key global-map "\C-ci" #'elnawe::open-config-file) ; Binds `C-ci' to open the configuration
#+END_SRC

** Emacsclient and Job Control

Emacsclient opens a frame that runs over the Daemon instead of creating
a new instance. Here I just override the way that =C-x C-c= works to
prompt a question before closing the frame as I do when I use =emacs=.

Also, since I don't use =Job control mode= in my Terminal, i unbind the
=C-z= and =C-x C-z= command =(suspend-emacs)=.

#+BEGIN_SRC emacs-lisp
(defun elnawe::emacsclient/promt-before-closing-frame ()
  "Prompts before closing a frame with `C-x C-c' like `emacs' does"
  (interactive)
  (if (y-or-n-p "Are you sure you want to exit Emacs? ")
      (save-buffers-kill-terminal)))

(global-set-key (kbd "C-x C-c") #'elnawe::emacsclient/promt-before-closing-frame)
(global-unset-key (kbd "C-z"))
(global-unset-key (kbd "C-x C-z"))
#+END_SRC

** Helpers

This is a set of helper functions that are used in this configuration.

#+BEGIN_SRC emacs-lisp
(defun elnawe::start-with-delay (FUNC)
  "Runs `FUNC' with a delay declared in
  `elnawe/start-time-seconds'. This function should be used to
  run smaller apps that are not crucial for Emacs to work"
  (run-at-time elnawe/start-time-seconds nil (funcall FUNC)))

(defun elnawe::load-package-dir (PACKAGE)
  "Returns package `PACKAGE' from /packages directory"
  (concat user-emacs-directory "packages/" PACKAGE))

(defun elnawe::open-config-file ()
  "Opens the config file `configuration.org' on a new buffer"
  (interactive)
  (find-file "~/.emacs.d/configuration.org"))

(defun elnawe::append-to-path (PATH)
  "Add a path both to the $PATH variable and to Emacs' exec-path."
  (setenv "PATH" (concat (getenv "PATH") ":" PATH))
  (add-to-list 'exec-path PATH))

(defun elnawe::get-configurations-folder ()
  "Returns the folder where configuration files are stored"
  (concat (getenv "HOME") "/.emacs.config"))

(defun elnawe::kill-current-buffer ()
  "Kill current buffer without prompting"
  (interactive)
  (kill-buffer (current-buffer)))
#+END_SRC

** OS Specific Configurations

Because I use Emacs everywhere, I need some extra configurations.

*** MacOS

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   exec-path (append exec-path '("/usr/local/bin"))  ; Add Homebrew path
   ns-command-modifier 'meta                         ; Meta key is Command
   ns-option-modifier nil                            ; I use Alt/Option to expand my keyboard layout
   ns-right-option-modifier 'super                   ; Never use right Alt key so I can use it as Super key
   ns-use-srgb-colorspace nil))                      ; Using different colorspace for Mac
#+END_SRC

Intializing env for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :if (memq window-system '(mac ns))
  :config (exec-path-from-shell-initialize))
#+END_SRC

*** Terminal

My terminal Emacs configuration, the one that I use the most, actually.

#+BEGIN_SRC emacs-lisp
(when (not window-system)
  (xterm-mouse-mode))
#+END_SRC

*** Window System

#+BEGIN_SRC emacs-lisp
(when window-system
  (global-set-key (kbd "C-2") 'set-mark-command)
  (scroll-bar-mode 0)
  (fringe-mode 0))
#+END_SRC

** Load =.custom.el=

You can use the customization interface that Emacs provide but when you
edit something, =init.el= is overriden with the new configuration. To
fix this, I move the Emacs customization changes to a new file and then
I load it.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** Load =secrets=

This loads a collection of secret and sensible information. I keep this
file separated to maintain privacy.

#+BEGIN_SRC emacs-lisp
(load "~/.elnawe.secrets/.emacs" t)
#+END_SRC

* Emacs everyday

** Backup Copies

Manage the backup copies. Always keeping them but save them inside Emacs
directory.

#+BEGIN_SRC emacs-lisp
(setq-default
 backup-by-copying t
 backup-directory-alist '(("." . "~/.emacs.config/saves"))
 delete-old-versions 'never
 make-backup-files t
 version-control 'numbered)
#+END_SRC

** Fill paragraph automatically

When I'm in =text-mode= I want my paragraph to be just the lenght of my
ruler. Also, I don't want to use =M-q= to adjust it by myself, because
Emacs allow me to do it automatically!

#+BEGIN_SRC emacs-lisp
(use-package simple
  :ensure nil
  :init
  (add-hook 'text-mode-hook #'turn-on-auto-fill))
#+END_SRC

** Navigation

Navigation its an important thing in Emacs, specially when you just use
the keyboard.

*** Beginning of line

This is a better =move-beginning-of-line= function that also goes to
beginning after indentation.

#+BEGIN_SRC emacs-lisp
(defun elnawe::dwin/beginning-of-line ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))

(global-set-key [remap move-beginning-of-line] #'elnawe::dwin/beginning-of-line)
#+END_SRC

*** Comment Block

A terminal-emacs fix.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x ;") #'comment-or-uncomment-region)
#+END_SRC

*** Kill Current Buffer

Assume I want to kill buffer with =C-x k= without asking.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x k") #'elnawe::kill-current-buffer)
#+END_SRC

** Restart Emacs

When I am updating or changing some configuration on my Emacs I like to
restart it to clean up everything I removed. There's an excellent
package to do that and it's called =restart-emacs=. Instead of =C-x C-c=
(quit-emacs) I use =C-x C-M-c= to restart it.

#+BEGIN_SRC emacs-lisp
(use-package restart-emacs
  :bind
  ("C-x C-M-c" . restart-emacs))
#+END_SRC

** Window management

Window management is something you have to do in Emacs, and you'll have
to do it a lot. This is a great set of configurations to make it look
and feel easy to do.

*** Destkop

For Emacs =desktop= is the working session you left off when closing it.
I like to keep it always there so I can continue from that point.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :ensure nil
  :demand t
  :config
  (desktop-save-mode))
#+END_SRC

*** Moving through windows

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-c m h". windmove-left)
   ("C-c m l". windmove-right)
   ("C-c m k". windmove-up)
   ("C-c m j". windmove-down)
   ("C-c m o" . other-window)))
#+END_SRC

*** Splitting Windows

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/create-bottom-and-switch ()
  "Creates a new window to the bottom and then switch to it"
  (interactive)
  (split-window-below)
  (balance-windows)
  (other-window 1))

(defun elnawe::window/create-right-and-switch ()
  "Creates a new window to the right and then switch to it"
  (interactive)
  (split-window-right)
  (balance-windows)
  (other-window 1))

(global-set-key (kbd "C-x 2") 'elnawe::window/create-bottom-and-switch)
(global-set-key (kbd "C-x 3") 'elnawe::window/create-right-and-switch)
(global-set-key (kbd "C-x `") 'ivy-switch-buffer-other-window)
#+END_SRC

*** Temporal Buffers

#+BEGIN_SRC emacs-lisp
(defun elnawe::window/split-vertically-for-temp-buffers ()
  (when (one-window-p t)
    (split-window-vertically)))

(add-hook 'temp-buffer-window-setup-hook
          'elnawe::window/split-vertically-for-temp-buffers)
#+END_SRC

*** Undo/Redo Configurations

Sometimes you close windows or change their layout without meaning to.
Thanks to Emacs =winner= mode helps me to go back if that happens.

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :defer 1
  :bind
  (("C-c b M-h" . winner-undo)
   ("C-c b M-l" . winner-redo))
  :init
  (winner-mode))
#+END_SRC

* Programming

I use Emacs for everything, even code. I like to keep it good looking
but really functional.

** Kill Line/Region

Instead of the default =C-w=, this function overrides that feature to
cut the line where you at if there's no region selected.

#+BEGIN_SRC emacs-lisp
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead"
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

** Languages

*** C

#+BEGIN_SRC emacs-lisp
(setq-default
 c-basic-offset 4
 c-default-style "user")
#+END_SRC

*** CSS

#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :ensure nil
    :config
    (setq-default css-indent-offset 4))

  (use-package scss-mode
    :ensure nil
    :mode ("\\.sass\\'" "\\.scss\\'"))
#+END_SRC

*** Golang

Install =go-mode=.

#+BEGIN_SRC emacs-lisp
(use-package go-mode)
#+END_SRC

Define =$GOPATH= and tell Emacs where to find Go binaries.

#+BEGIN_SRC emacs-lisp
(setenv "GOPATH" (concat (getenv "HOME") "/go"))
(elnawe::append-to-path (concat (getenv "GOPATH") "/bin"))
#+END_SRC

Run =goimports= on every file when saving. This formats the file and
automatically updates the list of imports. This requires =goimports=.

#+BEGIN_SRC emacs-lisp
(setq gofmt-command "goimports")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

When working with Go:

- Use =company-mode= with Go backend. This requires =gocode=,
- Redefine the =compile= command to a Go-specific command.

#+BEGIN_SRC emacs-lisp
(add-hook 'go-mode-hook
          (lambda ()
            (if (not (string-match "go" compile-command))
                (set (make-local-variable 'compile-command)
                     "go build -v && go test -v && go vet"))))
#+END_SRC

*** HTML

Using HTML mode defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :ensure nil
  :init
  (add-hook 'html-mode-hook #'sgml-electric-tag-pair-mode)
  (add-hook 'html-mode-hook #'sgml-name-8bit-mode)
  :config
  (setq sgml-basic-offset 4))
#+END_SRC

*** JavaScript

#+BEGIN_SRC emacs-lisp
(use-package js
  :init
  (add-hook 'js-mode #'js2-mode))

(use-package js2-mode
  :mode ("\\.js\\'")
  :config
  (setq js-indent-level 4))

(use-package json-mode
  :init
  (add-hook 'json-mode-hook
            (lambda ()
              (make-local-variable 'js-indent-level)
              (setq js-indent-level 2))))

(use-package rjsx-mode
  :mode ("/swa-ui-app/.*\\.js$")
  :config
  (setq js-indent-level 4))

(use-package tide)

(use-package typescript-mode
  :init
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (eldoc-mode 1)
    (tide-hl-identifier-mode))
  (add-hook 'before-save-hook #'tide-format-before-save)
  (add-hook 'typescript-mode-hook #'setup-tide-mode))
#+END_SRC

*** Markdown

Mostly I use =org-mode=, but sometimes you need to write down your
README files.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode ("INSTALL\\'" "LICENSE\\'" "README\\'" "\\.md\\'" "\\.markdown\\'")
    :config
    (setq
     markdown-asymmetric-header t
     markdown-split-window-direction 'right))
#+END_SRC

*** Org

My whole configuration is written in =org-mode=.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure nil
  :init
  (add-hook 'org-mode-hook #'org-bullets-mode)
  :config
  (setq
   org-descriptive-links nil
   org-ellipsis "\u21b4"
   org-startup-folded nil
   org-startup-truncated nil))

(use-package org-src
  :ensure nil
  :after org
  :config
  (setq
   org-edit-src-content-indentation 0
   org-edit-src-persistent-message nil
   org-src-fontify-natively t
   org-src-tab-acts-natively t
   org-src-window-setup 'current-window))
#+END_SRC

** Multiple Cursors

I actually like some of the features that modern IDE provides, like
multiple cursor editing. It's great that Emacs can do that as well!

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :bind
  (("C-c l e" . mc/edit-lines)
   ("C-c l l" . mc/mark-all-words-like-this)))
#+END_SRC

** Parentheses and Delimiters

When programming you use a lot of =()= or ={}= so I pulled out a nice
configuration to manage this delimiters.

*** Highlighing

#+BEGIN_SRC emacs-lisp
(use-package show-paren-mode
  :ensure nil
  :init
  (show-paren-mode t))
#+END_SRC

** Project Management

I love =projectile= and I think its the best project management tool
you'll ever need in Emacs.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" (elnawe::get-configurations-folder))
   projectile-enable-caching t
   projectile-keymap-prefix (kbd "C-c p")
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" (elnawe::get-configurations-folder))
   projectile-mode-line '(:eval (projectile-project-name))
   projectile-switch-project-action 'projectile-find-file)
  (projectile-global-mode))
#+END_SRC

** Search and Replace

Better search and replace with =anzu=. This is a known =vim= package
that [[https://github.com/syohex/emacs-anzu][syohex]] ported to Emacs.
Also, here I've some =isearch= configuration to work with better regexp
searching mechanics.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :init
  (global-anzu-mode)
  :config
  (setq
   anzu-cons-mode-line-p nil)
  (global-set-key [remap query-replace] 'anzu-query-replace)
  (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp))

(use-package isearch
  :ensure nil
  :bind
  (:map isearch-mode-map
        ("M-j" . isearch-ring-advance)
        ("M-k" . isearch-ring-retreat)
        :map minibuffer-local-isearch-map
        ("M-j" . next-history-element)
        ("M-k" . previous-history-element))
  :config
  (setq
   isearch-allow-scroll t
   lazy-highlight-cleanup nil
   lazy-highlight-initial-delay 0))
#+END_SRC

** Tree View

I don't use this often but it's a good thing to have in hand if I need
to find a file by its folder.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :bind
  (([f6] . neotree-toggle)
   ("M-2" . neotree-toggle)
   :map neotree-mode-map
   ("<return>" . neotree-enter)
   ("c" . neotree-create-node)
   ("d" . neotree-delete-node)
   ("j" . neotree-next-line)
   ("k" . neotree-previous-line)
   ("r" . neotree-rename-node)
   ("s" . neotree-dir))
  :config
  (setq
   neo-autorefresh t
   neo-force-change-root t
   neo-smart-open t
   neo-theme 'arrow
   neo-vc-integration '(face char)
   neo-window-width 50
   neo-window-position 'right))
#+END_SRC

** Whitespaces

Highlight trailing whitespaces, tabs and empty lines. Also remove them
when saving the file.


#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :demand t
  :ensure nil
  :init
  (add-hook 'before-save-hook #'delete-trailing-whitespace)
  (add-hook 'prog-mode-hook #'whitespace-turn-on)
  (add-hook 'text-mode-hook #'whitespace-turn-on)
  :config
  (setq whitespace-style '(face tab trailing)))
#+END_SRC

** Word Highlighting

Highlight words like `NOTE`, `TODO`, `FIXME` or `BUG` when in programming mode.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook
          (lambda ()
            (font-lock-add-keywords nil
                                    '(("\\<\\(FIXME\\|NOTE\\|TODO\\|BUG\\):" 1 font-lock-warning-face t)))))
#+END_SRC

* Major features

** Help

One great feature of Emacs is the self-documentation. This little
configuration makes navigating through it a little bit easier.

#+BEGIN_SRC emacs-lisp
(use-package help-mode
  :ensure nil
  :bind
  (:map help-mode-map
        ("q" . kill-buffer-and-window)
        ("<" . help-go-back)
        (">" . help-go-forward)))
#+END_SRC

** Mode Line

Started with =spaceline= which is a nice looking mode-line based on
=powerline= and extracted from =Spacemacs= but I always wanted to have
my own mode-line configuration. This is probably an always work in
progress.

#+BEGIN_SRC emacs-lisp
(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
  `(propertize ,STR 'face (list ,@PROPS)))

(defun get-buffer-state ()
  (concat
   "["
   (cond
    (buffer-read-only "R")
    ((buffer-modified-p) (with-face "M" '(:inherit (mode-line-buffer-id))))
    (t " "))
   "]"))

(setq-default
 mode-line-format
 (list
  " "
  '(:eval (get-buffer-state))
  (with-face " %b" '(:inherit (mode-line-buffer-id)))
  "  %p L%02l C%02c"
  "    (%m) "
  '(:eval (projectile-project-name))
  " "
  '(:eval (anzu--update-mode-line))))
#+END_SRC

* Theming

** Custom theme

So, I love *Zenburn* but I've found a pretty good theme out thre that
doesn't vary a lot from Zenburn and at the same time it looks pretty
similar of what Jonathan Blow, which looks great. I've a copy of my old
Zenburn configuration in [[file+emacs:zenburn-configuration.org][here]]

#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path "~/.emacs.d/theme")

(load-theme 'nawe t)
#+END_SRC
